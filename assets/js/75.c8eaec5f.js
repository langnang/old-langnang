(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{544:function(n,e,s){"use strict";s.r(e);var a=s(18),t=Object(a.a)({},(function(){var n=this,e=n.$createElement,s=n._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"generator-函数的语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generator-函数的语法"}},[n._v("#")]),n._v(" Generator 函数的语法")]),n._v(" "),s("ol",[s("li",[s("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/generator#%E7%AE%80%E4%BB%8B",target:"_blank",rel:"noopener noreferrer"}},[n._v("简介"),s("OutboundLink")],1)]),n._v(" "),s("li",[s("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/generator#next%20%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0",target:"_blank",rel:"noopener noreferrer"}},[n._v("next 方法的参数"),s("OutboundLink")],1)]),n._v(" "),s("li",[s("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/generator#for...of%20%E5%BE%AA%E7%8E%AF",target:"_blank",rel:"noopener noreferrer"}},[n._v("for...of 循环"),s("OutboundLink")],1)]),n._v(" "),s("li",[s("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/generator#Generator.prototype.throw()",target:"_blank",rel:"noopener noreferrer"}},[n._v("Generator.prototype.throw()"),s("OutboundLink")],1)]),n._v(" "),s("li",[s("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/generator#Generator.prototype.return()",target:"_blank",rel:"noopener noreferrer"}},[n._v("Generator.prototype.return()"),s("OutboundLink")],1)]),n._v(" "),s("li",[s("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/generator#next()%E3%80%81throw()%E3%80%81return()%20%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9",target:"_blank",rel:"noopener noreferrer"}},[n._v("next()、throw()、return() 的共同点"),s("OutboundLink")],1)]),n._v(" "),s("li",[s("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/generator#yield*%20%E8%A1%A8%E8%BE%BE%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"}},[n._v("yield* 表达式"),s("OutboundLink")],1)]),n._v(" "),s("li",[s("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/generator#%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%20Generator%20%E5%87%BD%E6%95%B0",target:"_blank",rel:"noopener noreferrer"}},[n._v("作为对象属性的 Generator 函数"),s("OutboundLink")],1)]),n._v(" "),s("li",[s("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/generator#Generator%20%E5%87%BD%E6%95%B0%E7%9A%84this",target:"_blank",rel:"noopener noreferrer"}},[n._v("Generator 函数的 this"),s("OutboundLink")],1)]),n._v(" "),s("li",[s("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/generator#%E5%90%AB%E4%B9%89",target:"_blank",rel:"noopener noreferrer"}},[n._v("含义"),s("OutboundLink")],1)]),n._v(" "),s("li",[s("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/generator#%E5%BA%94%E7%94%A8",target:"_blank",rel:"noopener noreferrer"}},[n._v("应用"),s("OutboundLink")],1)])]),n._v(" "),s("h2",{attrs:{id:"简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[n._v("#")]),n._v(" 简介")]),n._v(" "),s("h3",{attrs:{id:"基本概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[n._v("#")]),n._v(" 基本概念")]),n._v(" "),s("p",[n._v("Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。")]),n._v(" "),s("p",[n._v("Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。")]),n._v(" "),s("p",[n._v("执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。")]),n._v(" "),s("p",[n._v("形式上，Generator 函数是一个普通函数，但是有两个特征。一是，"),s("code",[n._v("function")]),n._v("关键字与函数名之间有一个星号；二是，函数体内部使用"),s("code",[n._v("yield")]),n._v("表达式，定义不同的内部状态（"),s("code",[n._v("yield")]),n._v("在英语里的意思就是“产出”）。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloWorldGenerator();\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br")])]),s("p",[n._v("上面代码定义了一个 Generator 函数"),s("code",[n._v("helloWorldGenerator")]),n._v("，它内部有两个"),s("code",[n._v("yield")]),n._v("表达式（"),s("code",[n._v("hello")]),n._v("和"),s("code",[n._v("world")]),n._v("），即该函数有三个状态：hello，world 和 return 语句（结束执行）。")]),n._v(" "),s("p",[n._v("然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。")]),n._v(" "),s("p",[n._v("下一步，必须调用遍历器对象的"),s("code",[n._v("next")]),n._v("方法，使得指针移向下一个状态。也就是说，每次调用"),s("code",[n._v("next")]),n._v("方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个"),s("code",[n._v("yield")]),n._v("表达式（或"),s("code",[n._v("return")]),n._v("语句）为止。换言之，Generator 函数是分段执行的，"),s("code",[n._v("yield")]),n._v("表达式是暂停执行的标记，而"),s("code",[n._v("next")]),n._v("方法可以恢复执行。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("hw.next()\n// { value: 'hello', done: false }\n\nhw.next()\n// { value: 'world', done: false }\n\nhw.next()\n// { value: 'ending', done: true }\n\nhw.next()\n// { value: undefined, done: true }\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br")])]),s("p",[n._v("上面代码一共调用了四次"),s("code",[n._v("next")]),n._v("方法。")]),n._v(" "),s("p",[n._v("第一次调用，Generator 函数开始执行，直到遇到第一个"),s("code",[n._v("yield")]),n._v("表达式为止。"),s("code",[n._v("next")]),n._v("方法返回一个对象，它的"),s("code",[n._v("value")]),n._v("属性就是当前"),s("code",[n._v("yield")]),n._v("表达式的值"),s("code",[n._v("hello")]),n._v("，"),s("code",[n._v("done")]),n._v("属性的值"),s("code",[n._v("false")]),n._v("，表示遍历还没有结束。")]),n._v(" "),s("p",[n._v("第二次调用，Generator 函数从上次"),s("code",[n._v("yield")]),n._v("表达式停下的地方，一直执行到下一个"),s("code",[n._v("yield")]),n._v("表达式。"),s("code",[n._v("next")]),n._v("方法返回的对象的"),s("code",[n._v("value")]),n._v("属性就是当前"),s("code",[n._v("yield")]),n._v("表达式的值"),s("code",[n._v("world")]),n._v("，"),s("code",[n._v("done")]),n._v("属性的值"),s("code",[n._v("false")]),n._v("，表示遍历还没有结束。")]),n._v(" "),s("p",[n._v("第三次调用，Generator 函数从上次"),s("code",[n._v("yield")]),n._v("表达式停下的地方，一直执行到"),s("code",[n._v("return")]),n._v("语句（如果没有"),s("code",[n._v("return")]),n._v("语句，就执行到函数结束）。"),s("code",[n._v("next")]),n._v("方法返回的对象的"),s("code",[n._v("value")]),n._v("属性，就是紧跟在"),s("code",[n._v("return")]),n._v("语句后面的表达式的值（如果没有"),s("code",[n._v("return")]),n._v("语句，则"),s("code",[n._v("value")]),n._v("属性的值为"),s("code",[n._v("undefined")]),n._v("），"),s("code",[n._v("done")]),n._v("属性的值"),s("code",[n._v("true")]),n._v("，表示遍历已经结束。")]),n._v(" "),s("p",[n._v("第四次调用，此时 Generator 函数已经运行完毕，"),s("code",[n._v("next")]),n._v("方法返回对象的"),s("code",[n._v("value")]),n._v("属性为"),s("code",[n._v("undefined")]),n._v("，"),s("code",[n._v("done")]),n._v("属性为"),s("code",[n._v("true")]),n._v("。以后再调用"),s("code",[n._v("next")]),n._v("方法，返回的都是这个值。")]),n._v(" "),s("p",[n._v("总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的"),s("code",[n._v("next")]),n._v("方法，就会返回一个有着"),s("code",[n._v("value")]),n._v("和"),s("code",[n._v("done")]),n._v("两个属性的对象。"),s("code",[n._v("value")]),n._v("属性表示当前的内部状态的值，是"),s("code",[n._v("yield")]),n._v("表达式后面那个表达式的值；"),s("code",[n._v("done")]),n._v("属性是一个布尔值，表示是否遍历结束。")]),n._v(" "),s("p",[n._v("ES6 没有规定，"),s("code",[n._v("function")]),n._v("关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function * foo(x, y) { ··· }\nfunction *foo(x, y) { ··· }\nfunction* foo(x, y) { ··· }\nfunction*foo(x, y) { ··· }\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br")])]),s("p",[n._v("由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在"),s("code",[n._v("function")]),n._v("关键字后面。本书也采用这种写法。")]),n._v(" "),s("h3",{attrs:{id:"yield-表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#yield-表达式"}},[n._v("#")]),n._v(" yield 表达式")]),n._v(" "),s("p",[n._v("由于 Generator 函数返回的遍历器对象，只有调用"),s("code",[n._v("next")]),n._v("方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。"),s("code",[n._v("yield")]),n._v("表达式就是暂停标志。")]),n._v(" "),s("p",[n._v("遍历器对象的"),s("code",[n._v("next")]),n._v("方法的运行逻辑如下。")]),n._v(" "),s("p",[n._v("（1）遇到"),s("code",[n._v("yield")]),n._v("表达式，就暂停执行后面的操作，并将紧跟在"),s("code",[n._v("yield")]),n._v("后面的那个表达式的值，作为返回的对象的"),s("code",[n._v("value")]),n._v("属性值。")]),n._v(" "),s("p",[n._v("（2）下一次调用"),s("code",[n._v("next")]),n._v("方法时，再继续往下执行，直到遇到下一个"),s("code",[n._v("yield")]),n._v("表达式。")]),n._v(" "),s("p",[n._v("（3）如果没有再遇到新的"),s("code",[n._v("yield")]),n._v("表达式，就一直运行到函数结束，直到"),s("code",[n._v("return")]),n._v("语句为止，并将"),s("code",[n._v("return")]),n._v("语句后面的表达式的值，作为返回的对象的"),s("code",[n._v("value")]),n._v("属性值。")]),n._v(" "),s("p",[n._v("（4）如果该函数没有"),s("code",[n._v("return")]),n._v("语句，则返回的对象的"),s("code",[n._v("value")]),n._v("属性值为"),s("code",[n._v("undefined")]),n._v("。")]),n._v(" "),s("p",[n._v("需要注意的是，"),s("code",[n._v("yield")]),n._v("表达式后面的表达式，只有当调用"),s("code",[n._v("next")]),n._v("方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* gen() {\n  yield  123 + 456;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br")])]),s("p",[n._v("上面代码中，"),s("code",[n._v("yield")]),n._v("后面的表达式"),s("code",[n._v("123 + 456")]),n._v("，不会立即求值，只会在"),s("code",[n._v("next")]),n._v("方法将指针移到这一句时，才会求值。")]),n._v(" "),s("p",[s("code",[n._v("yield")]),n._v("表达式与"),s("code",[n._v("return")]),n._v("语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到"),s("code",[n._v("yield")]),n._v("，函数暂停执行，下一次再从该位置继续向后执行，而"),s("code",[n._v("return")]),n._v("语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）"),s("code",[n._v("return")]),n._v("语句，但是可以执行多次（或者说多个）"),s("code",[n._v("yield")]),n._v("表达式。正常函数只能返回一个值，因为只能执行一次"),s("code",[n._v("return")]),n._v("；Generator 函数可以返回一系列的值，因为可以有任意多个"),s("code",[n._v("yield")]),n._v("。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。")]),n._v(" "),s("p",[n._v("Generator 函数可以不用"),s("code",[n._v("yield")]),n._v("表达式，这时就变成了一个单纯的暂缓执行函数。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* f() {\n  console.log('执行了！')\n}\n\nvar generator = f();\n\nsetTimeout(function () {\n  generator.next()\n}, 2000);\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br")])]),s("p",[n._v("上面代码中，函数"),s("code",[n._v("f")]),n._v("如果是普通函数，在为变量"),s("code",[n._v("generator")]),n._v("赋值时就会执行。但是，函数"),s("code",[n._v("f")]),n._v("是一个 Generator 函数，就变成只有调用"),s("code",[n._v("next")]),n._v("方法时，函数"),s("code",[n._v("f")]),n._v("才会执行。")]),n._v(" "),s("p",[n._v("另外需要注意，"),s("code",[n._v("yield")]),n._v("表达式只能用在 Generator 函数里面，用在其他地方都会报错。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("(function (){\n  yield 1;\n})()\n// SyntaxError: Unexpected number\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br")])]),s("p",[n._v("上面代码在一个普通函数中使用"),s("code",[n._v("yield")]),n._v("表达式，结果产生一个句法错误。")]),n._v(" "),s("p",[n._v("下面是另外一个例子。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var arr = [1, [[2, 3], 4], [5, 6]];\n\nvar flat = function* (a) {\n  a.forEach(function (item) {\n    if (typeof item !== 'number') {\n      yield* flat(item);\n    } else {\n      yield item;\n    }\n  });\n};\n\nfor (var f of flat(arr)){\n  console.log(f);\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br")])]),s("p",[n._v("上面代码也会产生句法错误，因为"),s("code",[n._v("forEach")]),n._v("方法的参数是一个普通函数，但是在里面使用了"),s("code",[n._v("yield")]),n._v("表达式（这个函数里面还使用了"),s("code",[n._v("yield*")]),n._v("表达式，详细介绍见后文）。一种修改方法是改用"),s("code",[n._v("for")]),n._v("循环。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var arr = [1, [[2, 3], 4], [5, 6]];\n\nvar flat = function* (a) {\n  var length = a.length;\n  for (var i = 0; i < length; i++) {\n    var item = a[i];\n    if (typeof item !== 'number') {\n      yield* flat(item);\n    } else {\n      yield item;\n    }\n  }\n};\n\nfor (var f of flat(arr)) {\n  console.log(f);\n}\n// 1, 2, 3, 4, 5, 6\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br")])]),s("p",[n._v("另外，"),s("code",[n._v("yield")]),n._v("表达式如果用在另一个表达式之中，必须放在圆括号里面。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* demo() {\n  console.log('Hello' + yield); // SyntaxError\n  console.log('Hello' + yield 123); // SyntaxError\n\n  console.log('Hello' + (yield)); // OK\n  console.log('Hello' + (yield 123)); // OK\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br")])]),s("p",[s("code",[n._v("yield")]),n._v("表达式用作函数参数或放在赋值表达式的右边，可以不加括号。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* demo() {\n  foo(yield 'a', yield 'b'); // OK\n  let input = yield; // OK\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br")])]),s("h3",{attrs:{id:"与-iterator-接口的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#与-iterator-接口的关系"}},[n._v("#")]),n._v(" 与 Iterator 接口的关系")]),n._v(" "),s("p",[n._v("上一章说过，任意一个对象的"),s("code",[n._v("Symbol.iterator")]),n._v("方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。")]),n._v(" "),s("p",[n._v("由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的"),s("code",[n._v("Symbol.iterator")]),n._v("属性，从而使得该对象具有 Iterator 接口。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myIterable] // [1, 2, 3]\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br")])]),s("p",[n._v("上面代码中，Generator 函数赋值给"),s("code",[n._v("Symbol.iterator")]),n._v("属性，从而使得"),s("code",[n._v("myIterable")]),n._v("对象具有了 Iterator 接口，可以被"),s("code",[n._v("...")]),n._v("运算符遍历了。")]),n._v(" "),s("p",[n._v("Generator 函数执行后，返回一个遍历器对象。该对象本身也具有"),s("code",[n._v("Symbol.iterator")]),n._v("属性，执行后返回自身。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* gen(){\n  // some code\n}\n\nvar g = gen();\n\ng[Symbol.iterator]() === g\n// true\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br")])]),s("p",[n._v("上面代码中，"),s("code",[n._v("gen")]),n._v("是一个 Generator 函数，调用它会生成一个遍历器对象"),s("code",[n._v("g")]),n._v("。它的"),s("code",[n._v("Symbol.iterator")]),n._v("属性，也是一个遍历器对象生成函数，执行后返回它自己。")]),n._v(" "),s("h2",{attrs:{id:"next-方法的参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#next-方法的参数"}},[n._v("#")]),n._v(" next 方法的参数")]),n._v(" "),s("p",[s("code",[n._v("yield")]),n._v("表达式本身没有返回值，或者说总是返回"),s("code",[n._v("undefined")]),n._v("。"),s("code",[n._v("next")]),n._v("方法可以带一个参数，该参数就会被当作上一个"),s("code",[n._v("yield")]),n._v("表达式的返回值。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* f() {\n  for(var i = 0; true; i++) {\n    var reset = yield i;\n    if(reset) { i = -1; }\n  }\n}\n\nvar g = f();\n\ng.next() // { value: 0, done: false }\ng.next() // { value: 1, done: false }\ng.next(true) // { value: 0, done: false }\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br")])]),s("p",[n._v("上面代码先定义了一个可以无限运行的 Generator 函数"),s("code",[n._v("f")]),n._v("，如果"),s("code",[n._v("next")]),n._v("方法没有参数，每次运行到"),s("code",[n._v("yield")]),n._v("表达式，变量"),s("code",[n._v("reset")]),n._v("的值总是"),s("code",[n._v("undefined")]),n._v("。当"),s("code",[n._v("next")]),n._v("方法带一个参数"),s("code",[n._v("true")]),n._v("时，变量"),s("code",[n._v("reset")]),n._v("就被重置为这个参数（即"),s("code",[n._v("true")]),n._v("），因此"),s("code",[n._v("i")]),n._v("会等于"),s("code",[n._v("-1")]),n._v("，下一轮循环就会从"),s("code",[n._v("-1")]),n._v("开始递增。")]),n._v(" "),s("p",[n._v("这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过"),s("code",[n._v("next")]),n._v("方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。")]),n._v(" "),s("p",[n._v("再看一个例子。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* foo(x) {\n  var y = 2 * (yield (x + 1));\n  var z = yield (y / 3);\n  return (x + y + z);\n}\n\nvar a = foo(5);\na.next() // Object{value:6, done:false}\na.next() // Object{value:NaN, done:false}\na.next() // Object{value:NaN, done:true}\n\nvar b = foo(5);\nb.next() // { value:6, done:false }\nb.next(12) // { value:8, done:false }\nb.next(13) // { value:42, done:true }\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br")])]),s("p",[n._v("上面代码中，第二次运行"),s("code",[n._v("next")]),n._v("方法的时候不带参数，导致 y 的值等于"),s("code",[n._v("2 * undefined")]),n._v("（即"),s("code",[n._v("NaN")]),n._v("），除以 3 以后还是"),s("code",[n._v("NaN")]),n._v("，因此返回对象的"),s("code",[n._v("value")]),n._v("属性也等于"),s("code",[n._v("NaN")]),n._v("。第三次运行"),s("code",[n._v("Next")]),n._v("方法的时候不带参数，所以"),s("code",[n._v("z")]),n._v("等于"),s("code",[n._v("undefined")]),n._v("，返回对象的"),s("code",[n._v("value")]),n._v("属性等于"),s("code",[n._v("5 + NaN + undefined")]),n._v("，即"),s("code",[n._v("NaN")]),n._v("。")]),n._v(" "),s("p",[n._v("如果向"),s("code",[n._v("next")]),n._v("方法提供参数，返回结果就完全不一样了。上面代码第一次调用"),s("code",[n._v("b")]),n._v("的"),s("code",[n._v("next")]),n._v("方法时，返回"),s("code",[n._v("x+1")]),n._v("的值"),s("code",[n._v("6")]),n._v("；第二次调用"),s("code",[n._v("next")]),n._v("方法，将上一次"),s("code",[n._v("yield")]),n._v("表达式的值设为"),s("code",[n._v("12")]),n._v("，因此"),s("code",[n._v("y")]),n._v("等于"),s("code",[n._v("24")]),n._v("，返回"),s("code",[n._v("y / 3")]),n._v("的值"),s("code",[n._v("8")]),n._v("；第三次调用"),s("code",[n._v("next")]),n._v("方法，将上一次"),s("code",[n._v("yield")]),n._v("表达式的值设为"),s("code",[n._v("13")]),n._v("，因此"),s("code",[n._v("z")]),n._v("等于"),s("code",[n._v("13")]),n._v("，这时"),s("code",[n._v("x")]),n._v("等于"),s("code",[n._v("5")]),n._v("，"),s("code",[n._v("y")]),n._v("等于"),s("code",[n._v("24")]),n._v("，所以"),s("code",[n._v("return")]),n._v("语句的值等于"),s("code",[n._v("42")]),n._v("。")]),n._v(" "),s("p",[n._v("注意，由于"),s("code",[n._v("next")]),n._v("方法的参数表示上一个"),s("code",[n._v("yield")]),n._v("表达式的返回值，所以在第一次使用"),s("code",[n._v("next")]),n._v("方法时，传递参数是无效的。V8 引擎直接忽略第一次使用"),s("code",[n._v("next")]),n._v("方法时的参数，只有从第二次使用"),s("code",[n._v("next")]),n._v("方法开始，参数才是有效的。从语义上讲，第一个"),s("code",[n._v("next")]),n._v("方法用来启动遍历器对象，所以不用带有参数。")]),n._v(" "),s("p",[n._v("再看一个通过"),s("code",[n._v("next")]),n._v("方法的参数，向 Generator 函数内部输入值的例子。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* dataConsumer() {\n  console.log('Started');\n  console.log(`1. ${yield}`);\n  console.log(`2. ${yield}`);\n  return 'result';\n}\n\nlet genObj = dataConsumer();\ngenObj.next();\n// Started\ngenObj.next('a')\n// 1. a\ngenObj.next('b')\n// 2. b\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br")])]),s("p",[n._v("上面代码是一个很直观的例子，每次通过"),s("code",[n._v("next")]),n._v("方法向 Generator 函数输入值，然后打印出来。")]),n._v(" "),s("p",[n._v("如果想要第一次调用"),s("code",[n._v("next")]),n._v("方法时，就能够输入值，可以在 Generator 函数外面再包一层。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function wrapper(generatorFunction) {\n  return function (...args) {\n    let generatorObject = generatorFunction(...args);\n    generatorObject.next();\n    return generatorObject;\n  };\n}\n\nconst wrapped = wrapper(function* () {\n  console.log(`First input: ${yield}`);\n  return 'DONE';\n});\n\nwrapped().next('hello!')\n// First input: hello!\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br")])]),s("p",[n._v("上面代码中，Generator 函数如果不用"),s("code",[n._v("wrapper")]),n._v("先包一层，是无法第一次调用"),s("code",[n._v("next")]),n._v("方法，就输入参数的。")]),n._v(" "),s("h2",{attrs:{id:"for-of-循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#for-of-循环"}},[n._v("#")]),n._v(" for...of 循环")]),n._v(" "),s("p",[s("code",[n._v("for...of")]),n._v("循环可以自动遍历 Generator 函数运行时生成的"),s("code",[n._v("Iterator")]),n._v("对象，且此时不再需要调用"),s("code",[n._v("next")]),n._v("方法。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\n\nfor (let v of foo()) {\n  console.log(v);\n}\n// 1 2 3 4 5\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br")])]),s("p",[n._v("上面代码使用"),s("code",[n._v("for...of")]),n._v("循环，依次显示 5 个"),s("code",[n._v("yield")]),n._v("表达式的值。这里需要注意，一旦"),s("code",[n._v("next")]),n._v("方法的返回对象的"),s("code",[n._v("done")]),n._v("属性为"),s("code",[n._v("true")]),n._v("，"),s("code",[n._v("for...of")]),n._v("循环就会中止，且不包含该返回对象，所以上面代码的"),s("code",[n._v("return")]),n._v("语句返回的"),s("code",[n._v("6")]),n._v("，不包括在"),s("code",[n._v("for...of")]),n._v("循环之中。")]),n._v(" "),s("p",[n._v("下面是一个利用 Generator 函数和"),s("code",[n._v("for...of")]),n._v("循环，实现斐波那契数列的例子。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* fibonacci() {\n  let [prev, curr] = [0, 1];\n  for (;;) {\n    yield curr;\n    [prev, curr] = [curr, prev + curr];\n  }\n}\n\nfor (let n of fibonacci()) {\n  if (n > 1000) break;\n  console.log(n);\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br")])]),s("p",[n._v("从上面代码可见，使用"),s("code",[n._v("for...of")]),n._v("语句时不需要使用"),s("code",[n._v("next")]),n._v("方法。")]),n._v(" "),s("p",[n._v("利用"),s("code",[n._v("for...of")]),n._v("循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用"),s("code",[n._v("for...of")]),n._v("循环，通过 Generator 函数为它加上这个接口，就可以用了。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* objectEntries(obj) {\n  let propKeys = Reflect.ownKeys(obj);\n\n  for (let propKey of propKeys) {\n    yield [propKey, obj[propKey]];\n  }\n}\n\nlet jane = { first: 'Jane', last: 'Doe' };\n\nfor (let [key, value] of objectEntries(jane)) {\n  console.log(`${key}: ${value}`);\n}\n// first: Jane\n// last: Doe\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br")])]),s("p",[n._v("上面代码中，对象"),s("code",[n._v("jane")]),n._v("原生不具备 Iterator 接口，无法用"),s("code",[n._v("for...of")]),n._v("遍历。这时，我们通过 Generator 函数"),s("code",[n._v("objectEntries")]),n._v("为它加上遍历器接口，就可以用"),s("code",[n._v("for...of")]),n._v("遍历了。加上遍历器接口的另一种写法是，将 Generator 函数加到对象的"),s("code",[n._v("Symbol.iterator")]),n._v("属性上面。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* objectEntries() {\n  let propKeys = Object.keys(this);\n\n  for (let propKey of propKeys) {\n    yield [propKey, this[propKey]];\n  }\n}\n\nlet jane = { first: 'Jane', last: 'Doe' };\n\njane[Symbol.iterator] = objectEntries;\n\nfor (let [key, value] of jane) {\n  console.log(`${key}: ${value}`);\n}\n// first: Jane\n// last: Doe\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br")])]),s("p",[n._v("除了"),s("code",[n._v("for...of")]),n._v("循环以外，扩展运算符（"),s("code",[n._v("...")]),n._v("）、解构赋值和"),s("code",[n._v("Array.from")]),n._v("方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* numbers () {\n  yield 1\n  yield 2\n  return 3\n  yield 4\n}\n\n// 扩展运算符\n[...numbers()] // [1, 2]\n\n// Array.from 方法\nArray.from(numbers()) // [1, 2]\n\n// 解构赋值\nlet [x, y] = numbers();\nx // 1\ny // 2\n\n// for...of 循环\nfor (let n of numbers()) {\n  console.log(n)\n}\n// 1\n// 2\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br")])]),s("h2",{attrs:{id:"generator-prototype-throw"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generator-prototype-throw"}},[n._v("#")]),n._v(" Generator.prototype.throw()")]),n._v(" "),s("p",[n._v("Generator 函数返回的遍历器对象，都有一个"),s("code",[n._v("throw")]),n._v("方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log('内部捕获', e);\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  i.throw('a');\n  i.throw('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 内部捕获 a\n// 外部捕获 b\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br")])]),s("p",[n._v("上面代码中，遍历器对象"),s("code",[n._v("i")]),n._v("连续抛出两个错误。第一个错误被 Generator 函数体内的"),s("code",[n._v("catch")]),n._v("语句捕获。"),s("code",[n._v("i")]),n._v("第二次抛出错误，由于 Generator 函数内部的"),s("code",[n._v("catch")]),n._v("语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的"),s("code",[n._v("catch")]),n._v("语句捕获。")]),n._v(" "),s("p",[s("code",[n._v("throw")]),n._v("方法可以接受一个参数，该参数会被"),s("code",[n._v("catch")]),n._v("语句接收，建议抛出"),s("code",[n._v("Error")]),n._v("对象的实例。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nvar i = g();\ni.next();\ni.throw(new Error('出错了！'));\n// Error: 出错了！(…)\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br")])]),s("p",[n._v("注意，不要混淆遍历器对象的"),s("code",[n._v("throw")]),n._v("方法和全局的"),s("code",[n._v("throw")]),n._v("命令。上面代码的错误，是用遍历器对象的"),s("code",[n._v("throw")]),n._v("方法抛出的，而不是用"),s("code",[n._v("throw")]),n._v("命令抛出的。后者只能被函数体外的"),s("code",[n._v("catch")]),n._v("语句捕获。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var g = function* () {\n  while (true) {\n    try {\n      yield;\n    } catch (e) {\n      if (e != 'a') throw e;\n      console.log('内部捕获', e);\n    }\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  throw new Error('a');\n  throw new Error('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 外部捕获 [Error: a]\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br")])]),s("p",[n._v("上面代码之所以只捕获了"),s("code",[n._v("a")]),n._v("，是因为函数体外的"),s("code",[n._v("catch")]),n._v("语句块，捕获了抛出的"),s("code",[n._v("a")]),n._v("错误以后，就不会再继续"),s("code",[n._v("try")]),n._v("代码块里面剩余的语句了。")]),n._v(" "),s("p",[n._v("如果 Generator 函数内部没有部署"),s("code",[n._v("try...catch")]),n._v("代码块，那么"),s("code",[n._v("throw")]),n._v("方法抛出的错误，将被外部"),s("code",[n._v("try...catch")]),n._v("代码块捕获。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var g = function* () {\n  while (true) {\n    yield;\n    console.log('内部捕获', e);\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  i.throw('a');\n  i.throw('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 外部捕获 a\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br")])]),s("p",[n._v("上面代码中，Generator 函数"),s("code",[n._v("g")]),n._v("内部没有部署"),s("code",[n._v("try...catch")]),n._v("代码块，所以抛出的错误直接被外部"),s("code",[n._v("catch")]),n._v("代码块捕获。")]),n._v(" "),s("p",[n._v("如果 Generator 函数内部和外部，都没有部署"),s("code",[n._v("try...catch")]),n._v("代码块，那么程序将报错，直接中断执行。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var gen = function* gen(){\n  yield console.log('hello');\n  yield console.log('world');\n}\n\nvar g = gen();\ng.next();\ng.throw();\n// hello\n// Uncaught undefined\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br")])]),s("p",[n._v("上面代码中，"),s("code",[n._v("g.throw")]),n._v("抛出错误以后，没有任何"),s("code",[n._v("try...catch")]),n._v("代码块可以捕获这个错误，导致程序报错，中断执行。")]),n._v(" "),s("p",[s("code",[n._v("throw")]),n._v("方法抛出的错误要被内部捕获，前提是必须至少执行过一次"),s("code",[n._v("next")]),n._v("方法。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* gen() {\n  try {\n    yield 1;\n  } catch (e) {\n    console.log('内部捕获');\n  }\n}\n\nvar g = gen();\ng.throw(1);\n// Uncaught 1\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br")])]),s("p",[n._v("上面代码中，"),s("code",[n._v("g.throw(1)")]),n._v("执行时，"),s("code",[n._v("next")]),n._v("方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行"),s("code",[n._v("next")]),n._v("方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时"),s("code",[n._v("throw")]),n._v("方法抛错只可能抛出在函数外部。")]),n._v(" "),s("p",[s("code",[n._v("throw")]),n._v("方法被捕获以后，会附带执行下一条"),s("code",[n._v("yield")]),n._v("表达式。也就是说，会附带执行一次"),s("code",[n._v("next")]),n._v("方法。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var gen = function* gen(){\n  try {\n    yield console.log('a');\n  } catch (e) {\n    // ...\n  }\n  yield console.log('b');\n  yield console.log('c');\n}\n\nvar g = gen();\ng.next() // a\ng.throw() // b\ng.next() // c\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br")])]),s("p",[n._v("上面代码中，"),s("code",[n._v("g.throw")]),n._v("方法被捕获以后，自动执行了一次"),s("code",[n._v("next")]),n._v("方法，所以会打印"),s("code",[n._v("b")]),n._v("。另外，也可以看到，只要 Generator 函数内部部署了"),s("code",[n._v("try...catch")]),n._v("代码块，那么遍历器的"),s("code",[n._v("throw")]),n._v("方法抛出的错误，不影响下一次遍历。")]),n._v(" "),s("p",[n._v("另外，"),s("code",[n._v("throw")]),n._v("命令与"),s("code",[n._v("g.throw")]),n._v("方法是无关的，两者互不影响。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var gen = function* gen(){\n  yield console.log('hello');\n  yield console.log('world');\n}\n\nvar g = gen();\ng.next();\n\ntry {\n  throw new Error();\n} catch (e) {\n  g.next();\n}\n// hello\n// world\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br")])]),s("p",[n._v("上面代码中，"),s("code",[n._v("throw")]),n._v("命令抛出的错误不会影响到遍历器的状态，所以两次执行"),s("code",[n._v("next")]),n._v("方法，都进行了正确的操作。")]),n._v(" "),s("p",[n._v("这种函数体内捕获错误的机制，大大方便了对错误的处理。多个"),s("code",[n._v("yield")]),n._v("表达式，可以只用一个"),s("code",[n._v("try...catch")]),n._v("代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次"),s("code",[n._v("catch")]),n._v("语句就可以了。")]),n._v(" "),s("p",[n._v("Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的"),s("code",[n._v("catch")]),n._v("捕获。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* foo() {\n  var x = yield 3;\n  var y = x.toUpperCase();\n  yield y;\n}\n\nvar it = foo();\n\nit.next(); // { value:3, done:false }\n\ntry {\n  it.next(42);\n} catch (err) {\n  console.log(err);\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br")])]),s("p",[n._v("上面代码中，第二个"),s("code",[n._v("next")]),n._v("方法向函数体内传入一个参数 42，数值是没有"),s("code",[n._v("toUpperCase")]),n._v("方法的，所以会抛出一个 TypeError 错误，被函数体外的"),s("code",[n._v("catch")]),n._v("捕获。")]),n._v(" "),s("p",[n._v("一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用"),s("code",[n._v("next")]),n._v("方法，将返回一个"),s("code",[n._v("value")]),n._v("属性等于"),s("code",[n._v("undefined")]),n._v("、"),s("code",[n._v("done")]),n._v("属性等于"),s("code",[n._v("true")]),n._v("的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* g() {\n  yield 1;\n  console.log('throwing an exception');\n  throw new Error('generator broke!');\n  yield 2;\n  yield 3;\n}\n\nfunction log(generator) {\n  var v;\n  console.log('starting generator');\n  try {\n    v = generator.next();\n    console.log('第一次运行next方法', v);\n  } catch (err) {\n    console.log('捕捉错误', v);\n  }\n  try {\n    v = generator.next();\n    console.log('第二次运行next方法', v);\n  } catch (err) {\n    console.log('捕捉错误', v);\n  }\n  try {\n    v = generator.next();\n    console.log('第三次运行next方法', v);\n  } catch (err) {\n    console.log('捕捉错误', v);\n  }\n  console.log('caller done');\n}\n\nlog(g());\n// starting generator\n// 第一次运行next方法 { value: 1, done: false }\n// throwing an exception\n// 捕捉错误 { value: 1, done: false }\n// 第三次运行next方法 { value: undefined, done: true }\n// caller done\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br")])]),s("p",[n._v("上面代码一共三次运行"),s("code",[n._v("next")]),n._v("方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。")]),n._v(" "),s("h2",{attrs:{id:"generator-prototype-return"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generator-prototype-return"}},[n._v("#")]),n._v(" Generator.prototype.return()")]),n._v(" "),s("p",[n._v("Generator 函数返回的遍历器对象，还有一个"),s("code",[n._v("return()")]),n._v("方法，可以返回给定的值，并且终结遍历 Generator 函数。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nvar g = gen();\n\ng.next()        // { value: 1, done: false }\ng.return('foo') // { value: \"foo\", done: true }\ng.next()        // { value: undefined, done: true }\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br")])]),s("p",[n._v("上面代码中，遍历器对象"),s("code",[n._v("g")]),n._v("调用"),s("code",[n._v("return()")]),n._v("方法后，返回值的"),s("code",[n._v("value")]),n._v("属性就是"),s("code",[n._v("return()")]),n._v("方法的参数"),s("code",[n._v("foo")]),n._v("。并且，Generator 函数的遍历就终止了，返回值的"),s("code",[n._v("done")]),n._v("属性为"),s("code",[n._v("true")]),n._v("，以后再调用"),s("code",[n._v("next()")]),n._v("方法，"),s("code",[n._v("done")]),n._v("属性总是返回"),s("code",[n._v("true")]),n._v("。")]),n._v(" "),s("p",[n._v("如果"),s("code",[n._v("return()")]),n._v("方法调用时，不提供参数，则返回值的"),s("code",[n._v("value")]),n._v("属性为"),s("code",[n._v("undefined")]),n._v("。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nvar g = gen();\n\ng.next() // { value: 1, done: false }\ng.return() // { value: undefined, done: true }\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br")])]),s("p",[n._v("如果 Generator 函数内部有"),s("code",[n._v("try...finally")]),n._v("代码块，且正在执行"),s("code",[n._v("try")]),n._v("代码块，那么"),s("code",[n._v("return()")]),n._v("方法会导致立刻进入"),s("code",[n._v("finally")]),n._v("代码块，执行完以后，整个函数才会结束。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* numbers () {\n  yield 1;\n  try {\n    yield 2;\n    yield 3;\n  } finally {\n    yield 4;\n    yield 5;\n  }\n  yield 6;\n}\nvar g = numbers();\ng.next() // { value: 1, done: false }\ng.next() // { value: 2, done: false }\ng.return(7) // { value: 4, done: false }\ng.next() // { value: 5, done: false }\ng.next() // { value: 7, done: true }\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br")])]),s("p",[n._v("上面代码中，调用"),s("code",[n._v("return()")]),n._v("方法后，就开始执行"),s("code",[n._v("finally")]),n._v("代码块，不执行"),s("code",[n._v("try")]),n._v("里面剩下的代码了，然后等到"),s("code",[n._v("finally")]),n._v("代码块执行完，再返回"),s("code",[n._v("return()")]),n._v("方法指定的返回值。")]),n._v(" "),s("h2",{attrs:{id:"next-、throw-、return-的共同点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#next-、throw-、return-的共同点"}},[n._v("#")]),n._v(" next()、throw()、return() 的共同点")]),n._v(" "),s("p",[s("code",[n._v("next()")]),n._v("、"),s("code",[n._v("throw()")]),n._v("、"),s("code",[n._v("return()")]),n._v("这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换"),s("code",[n._v("yield")]),n._v("表达式。")]),n._v(" "),s("p",[s("code",[n._v("next()")]),n._v("是将"),s("code",[n._v("yield")]),n._v("表达式替换成一个值。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("const g = function* (x, y) {\n  let result = yield x + y;\n  return result;\n};\n\nconst gen = g(1, 2);\ngen.next(); // Object {value: 3, done: false}\n\ngen.next(1); // Object {value: 1, done: true}\n// 相当于将 let result = yield x + y\n// 替换成 let result = 1;\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br")])]),s("p",[n._v("上面代码中，第二个"),s("code",[n._v("next(1)")]),n._v("方法就相当于将"),s("code",[n._v("yield")]),n._v("表达式替换成一个值"),s("code",[n._v("1")]),n._v("。如果"),s("code",[n._v("next")]),n._v("方法没有参数，就相当于替换成"),s("code",[n._v("undefined")]),n._v("。")]),n._v(" "),s("p",[s("code",[n._v("throw()")]),n._v("是将"),s("code",[n._v("yield")]),n._v("表达式替换成一个"),s("code",[n._v("throw")]),n._v("语句。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("gen.throw(new Error('出错了')); // Uncaught Error: 出错了\n// 相当于将 let result = yield x + y\n// 替换成 let result = throw(new Error('出错了'));\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br")])]),s("p",[s("code",[n._v("return()")]),n._v("是将"),s("code",[n._v("yield")]),n._v("表达式替换成一个"),s("code",[n._v("return")]),n._v("语句。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("gen.return(2); // Object {value: 2, done: true}\n// 相当于将 let result = yield x + y\n// 替换成 let result = return 2;\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br")])]),s("h2",{attrs:{id:"yield-表达式-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#yield-表达式-2"}},[n._v("#")]),n._v(" yield* 表达式")]),n._v(" "),s("p",[n._v("如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* foo() {\n  yield 'a';\n  yield 'b';\n}\n\nfunction* bar() {\n  yield 'x';\n  // 手动遍历 foo()\n  for (let i of foo()) {\n    console.log(i);\n  }\n  yield 'y';\n}\n\nfor (let v of bar()){\n  console.log(v);\n}\n// x\n// a\n// b\n// y\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br")])]),s("p",[n._v("上面代码中，"),s("code",[n._v("foo")]),n._v("和"),s("code",[n._v("bar")]),n._v("都是 Generator 函数，在"),s("code",[n._v("bar")]),n._v("里面调用"),s("code",[n._v("foo")]),n._v("，就需要手动遍历"),s("code",[n._v("foo")]),n._v("。如果有多个 Generator 函数嵌套，写起来就非常麻烦。")]),n._v(" "),s("p",[n._v("ES6 提供了"),s("code",[n._v("yield*")]),n._v("表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* bar() {\n  yield 'x';\n  yield* foo();\n  yield 'y';\n}\n\n// 等同于\nfunction* bar() {\n  yield 'x';\n  yield 'a';\n  yield 'b';\n  yield 'y';\n}\n\n// 等同于\nfunction* bar() {\n  yield 'x';\n  for (let v of foo()) {\n    yield v;\n  }\n  yield 'y';\n}\n\nfor (let v of bar()){\n  console.log(v);\n}\n// \"x\"\n// \"a\"\n// \"b\"\n// \"y\"\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br")])]),s("p",[n._v("再来看一个对比的例子。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* inner() {\n  yield 'hello!';\n}\n\nfunction* outer1() {\n  yield 'open';\n  yield inner();\n  yield 'close';\n}\n\nvar gen = outer1()\ngen.next().value // \"open\"\ngen.next().value // 返回一个遍历器对象\ngen.next().value // \"close\"\n\nfunction* outer2() {\n  yield 'open'\n  yield* inner()\n  yield 'close'\n}\n\nvar gen = outer2()\ngen.next().value // \"open\"\ngen.next().value // \"hello!\"\ngen.next().value // \"close\"\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br")])]),s("p",[n._v("上面例子中，"),s("code",[n._v("outer2")]),n._v("使用了"),s("code",[n._v("yield*")]),n._v("，"),s("code",[n._v("outer1")]),n._v("没使用。结果就是，"),s("code",[n._v("outer1")]),n._v("返回一个遍历器对象，"),s("code",[n._v("outer2")]),n._v("返回该遍历器对象的内部值。")]),n._v(" "),s("p",[n._v("从语法角度看，如果"),s("code",[n._v("yield")]),n._v("表达式后面跟的是一个遍历器对象，需要在"),s("code",[n._v("yield")]),n._v("表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为"),s("code",[n._v("yield*")]),n._v("表达式。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("let delegatedIterator = (function* () {\n  yield 'Hello!';\n  yield 'Bye!';\n}());\n\nlet delegatingIterator = (function* () {\n  yield 'Greetings!';\n  yield* delegatedIterator;\n  yield 'Ok, bye.';\n}());\n\nfor(let value of delegatingIterator) {\n  console.log(value);\n}\n// \"Greetings!\n// \"Hello!\"\n// \"Bye!\"\n// \"Ok, bye.\"\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br")])]),s("p",[n._v("上面代码中，"),s("code",[n._v("delegatingIterator")]),n._v("是代理者，"),s("code",[n._v("delegatedIterator")]),n._v("是被代理者。由于"),s("code",[n._v("yield* delegatedIterator")]),n._v("语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。")]),n._v(" "),s("p",[s("code",[n._v("yield*")]),n._v("后面的 Generator 函数（没有"),s("code",[n._v("return")]),n._v("语句时），等同于在 Generator 函数内部，部署一个"),s("code",[n._v("for...of")]),n._v("循环。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* concat(iter1, iter2) {\n  yield* iter1;\n  yield* iter2;\n}\n\n// 等同于\n\nfunction* concat(iter1, iter2) {\n  for (var value of iter1) {\n    yield value;\n  }\n  for (var value of iter2) {\n    yield value;\n  }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br")])]),s("p",[n._v("上面代码说明，"),s("code",[n._v("yield*")]),n._v("后面的 Generator 函数（没有"),s("code",[n._v("return")]),n._v("语句时），不过是"),s("code",[n._v("for...of")]),n._v("的一种简写形式，完全可以用后者替代前者。反之，在有"),s("code",[n._v("return")]),n._v("语句时，则需要用"),s("code",[n._v("var value = yield* iterator")]),n._v("的形式获取"),s("code",[n._v("return")]),n._v("语句的值。")]),n._v(" "),s("p",[n._v("如果"),s("code",[n._v("yield*")]),n._v("后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('function* gen(){\n  yield* ["a", "b", "c"];\n}\n\ngen().next() // { value:"a", done:false }\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br")])]),s("p",[n._v("上面代码中，"),s("code",[n._v("yield")]),n._v("命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。")]),n._v(" "),s("p",[n._v("实际上，任何数据结构只要有 Iterator 接口，就可以被"),s("code",[n._v("yield*")]),n._v("遍历。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("let read = (function* () {\n  yield 'hello';\n  yield* 'hello';\n})();\n\nread.next().value // \"hello\"\nread.next().value // \"h\"\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br")])]),s("p",[n._v("上面代码中，"),s("code",[n._v("yield")]),n._v("表达式返回整个字符串，"),s("code",[n._v("yield*")]),n._v("语句返回单个字符。因为字符串具有 Iterator 接口，所以被"),s("code",[n._v("yield*")]),n._v("遍历。")]),n._v(" "),s("p",[n._v("如果被代理的 Generator 函数有"),s("code",[n._v("return")]),n._v("语句，那么就可以向代理它的 Generator 函数返回数据。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('function* foo() {\n  yield 2;\n  yield 3;\n  return "foo";\n}\n\nfunction* bar() {\n  yield 1;\n  var v = yield* foo();\n  console.log("v: " + v);\n  yield 4;\n}\n\nvar it = bar();\n\nit.next()\n// {value: 1, done: false}\nit.next()\n// {value: 2, done: false}\nit.next()\n// {value: 3, done: false}\nit.next();\n// "v: foo"\n// {value: 4, done: false}\nit.next()\n// {value: undefined, done: true}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br")])]),s("p",[n._v("上面代码在第四次调用"),s("code",[n._v("next")]),n._v("方法的时候，屏幕上会有输出，这是因为函数"),s("code",[n._v("foo")]),n._v("的"),s("code",[n._v("return")]),n._v("语句，向函数"),s("code",[n._v("bar")]),n._v("提供了返回值。")]),n._v(" "),s("p",[n._v("再看一个例子。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* genFuncWithReturn() {\n  yield 'a';\n  yield 'b';\n  return 'The result';\n}\nfunction* logReturned(genObj) {\n  let result = yield* genObj;\n  console.log(result);\n}\n\n[...logReturned(genFuncWithReturn())]\n// The result\n// 值为 [ 'a', 'b' ]\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br")])]),s("p",[n._v("上面代码中，存在两次遍历。第一次是扩展运算符遍历函数"),s("code",[n._v("logReturned")]),n._v("返回的遍历器对象，第二次是"),s("code",[n._v("yield*")]),n._v("语句遍历函数"),s("code",[n._v("genFuncWithReturn")]),n._v("返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数"),s("code",[n._v("genFuncWithReturn")]),n._v("返回的遍历器对象。所以，最后的数据表达式得到的值等于"),s("code",[n._v("[ 'a', 'b' ]")]),n._v("。但是，函数"),s("code",[n._v("genFuncWithReturn")]),n._v("的"),s("code",[n._v("return")]),n._v("语句的返回值"),s("code",[n._v("The result")]),n._v("，会返回给函数"),s("code",[n._v("logReturned")]),n._v("内部的"),s("code",[n._v("result")]),n._v("变量，因此会有终端输出。")]),n._v(" "),s("p",[s("code",[n._v("yield*")]),n._v("命令可以很方便地取出嵌套数组的所有成员。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* iterTree(tree) {\n  if (Array.isArray(tree)) {\n    for(let i=0; i < tree.length; i++) {\n      yield* iterTree(tree[i]);\n    }\n  } else {\n    yield tree;\n  }\n}\n\nconst tree = [ 'a', ['b', 'c'], ['d', 'e'] ];\n\nfor(let x of iterTree(tree)) {\n  console.log(x);\n}\n// a\n// b\n// c\n// d\n// e\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br")])]),s("p",[n._v("由于扩展运算符"),s("code",[n._v("...")]),n._v("默认调用 Iterator 接口，所以上面这个函数也可以用于嵌套数组的平铺。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('[...iterTree(tree)] // ["a", "b", "c", "d", "e"]\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br")])]),s("p",[n._v("下面是一个稍微复杂的例子，使用"),s("code",[n._v("yield*")]),n._v("语句遍历完全二叉树。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("// 下面是二叉树的构造函数，\n// 三个参数分别是左树、当前节点和右树\nfunction Tree(left, label, right) {\n  this.left = left;\n  this.label = label;\n  this.right = right;\n}\n\n// 下面是中序（inorder）遍历函数。\n// 由于返回的是一个遍历器，所以要用generator函数。\n// 函数体内采用递归算法，所以左树和右树要用yield*遍历\nfunction* inorder(t) {\n  if (t) {\n    yield* inorder(t.left);\n    yield t.label;\n    yield* inorder(t.right);\n  }\n}\n\n// 下面生成二叉树\nfunction make(array) {\n  // 判断是否为叶节点\n  if (array.length == 1) return new Tree(null, array[0], null);\n  return new Tree(make(array[0]), array[1], make(array[2]));\n}\nlet tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);\n\n// 遍历二叉树\nvar result = [];\nfor (let node of inorder(tree)) {\n  result.push(node);\n}\n\nresult\n// ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br")])]),s("h2",{attrs:{id:"作为对象属性的-generator-函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作为对象属性的-generator-函数"}},[n._v("#")]),n._v(" 作为对象属性的 Generator 函数")]),n._v(" "),s("p",[n._v("如果一个对象的属性是 Generator 函数，可以简写成下面的形式。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("let obj = {\n  * myGeneratorMethod() {\n    ···\n  }\n};\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br")])]),s("p",[n._v("上面代码中，"),s("code",[n._v("myGeneratorMethod")]),n._v("属性前面有一个星号，表示这个属性是一个 Generator 函数。")]),n._v(" "),s("p",[n._v("它的完整形式如下，与上面的写法是等价的。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("let obj = {\n  myGeneratorMethod: function* () {\n    // ···\n  }\n};\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br")])]),s("h2",{attrs:{id:"generator-函数的this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generator-函数的this"}},[n._v("#")]),n._v(" Generator 函数的"),s("code",[n._v("this")])]),n._v(" "),s("p",[n._v("Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的"),s("code",[n._v("prototype")]),n._v("对象上的方法。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* g() {}\n\ng.prototype.hello = function () {\n  return 'hi!';\n};\n\nlet obj = g();\n\nobj instanceof g // true\nobj.hello() // 'hi!'\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br")])]),s("p",[n._v("上面代码表明，Generator 函数"),s("code",[n._v("g")]),n._v("返回的遍历器"),s("code",[n._v("obj")]),n._v("，是"),s("code",[n._v("g")]),n._v("的实例，而且继承了"),s("code",[n._v("g.prototype")]),n._v("。但是，如果把"),s("code",[n._v("g")]),n._v("当作普通的构造函数，并不会生效，因为"),s("code",[n._v("g")]),n._v("返回的总是遍历器对象，而不是"),s("code",[n._v("this")]),n._v("对象。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* g() {\n  this.a = 11;\n}\n\nlet obj = g();\nobj.next();\nobj.a // undefined\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br")])]),s("p",[n._v("上面代码中，Generator 函数"),s("code",[n._v("g")]),n._v("在"),s("code",[n._v("this")]),n._v("对象上面添加了一个属性"),s("code",[n._v("a")]),n._v("，但是"),s("code",[n._v("obj")]),n._v("对象拿不到这个属性。")]),n._v(" "),s("p",[n._v("Generator 函数也不能跟"),s("code",[n._v("new")]),n._v("命令一起用，会报错。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* F() {\n  yield this.x = 2;\n  yield this.y = 3;\n}\n\nnew F()\n// TypeError: F is not a constructor\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br")])]),s("p",[n._v("上面代码中，"),s("code",[n._v("new")]),n._v("命令跟构造函数"),s("code",[n._v("F")]),n._v("一起使用，结果报错，因为"),s("code",[n._v("F")]),n._v("不是构造函数。")]),n._v(" "),s("p",[n._v("那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用"),s("code",[n._v("next")]),n._v("方法，又可以获得正常的"),s("code",[n._v("this")]),n._v("？")]),n._v(" "),s("p",[n._v("下面是一个变通方法。首先，生成一个空对象，使用"),s("code",[n._v("call")]),n._v("方法绑定 Generator 函数内部的"),s("code",[n._v("this")]),n._v("。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* F() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\nvar obj = {};\nvar f = F.call(obj);\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nobj.a // 1\nobj.b // 2\nobj.c // 3\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br")])]),s("p",[n._v("上面代码中，首先是"),s("code",[n._v("F")]),n._v("内部的"),s("code",[n._v("this")]),n._v("对象绑定"),s("code",[n._v("obj")]),n._v("对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次"),s("code",[n._v("next")]),n._v("方法（因为"),s("code",[n._v("F")]),n._v("内部有两个"),s("code",[n._v("yield")]),n._v("表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在"),s("code",[n._v("obj")]),n._v("对象上了，因此"),s("code",[n._v("obj")]),n._v("对象也就成了"),s("code",[n._v("F")]),n._v("的实例。")]),n._v(" "),s("p",[n._v("上面代码中，执行的是遍历器对象"),s("code",[n._v("f")]),n._v("，但是生成的对象实例是"),s("code",[n._v("obj")]),n._v("，有没有办法将这两个对象统一呢？")]),n._v(" "),s("p",[n._v("一个办法就是将"),s("code",[n._v("obj")]),n._v("换成"),s("code",[n._v("F.prototype")]),n._v("。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* F() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\nvar f = F.call(F.prototype);\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nf.a // 1\nf.b // 2\nf.c // 3\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br")])]),s("p",[n._v("再将"),s("code",[n._v("F")]),n._v("改成构造函数，就可以对它执行"),s("code",[n._v("new")]),n._v("命令了。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* gen() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\n\nfunction F() {\n  return gen.call(gen.prototype);\n}\n\nvar f = new F();\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nf.a // 1\nf.b // 2\nf.c // 3\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br")])]),s("h2",{attrs:{id:"含义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#含义"}},[n._v("#")]),n._v(" 含义")]),n._v(" "),s("h3",{attrs:{id:"generator-与状态机"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generator-与状态机"}},[n._v("#")]),n._v(" Generator 与状态机")]),n._v(" "),s("p",[n._v("Generator 是实现状态机的最佳结构。比如，下面的"),s("code",[n._v("clock")]),n._v("函数就是一个状态机。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var ticking = true;\nvar clock = function() {\n  if (ticking)\n    console.log('Tick!');\n  else\n    console.log('Tock!');\n  ticking = !ticking;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br")])]),s("p",[n._v("上面代码的"),s("code",[n._v("clock")]),n._v("函数一共有两种状态（"),s("code",[n._v("Tick")]),n._v("和"),s("code",[n._v("Tock")]),n._v("），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var clock = function* () {\n  while (true) {\n    console.log('Tick!');\n    yield;\n    console.log('Tock!');\n    yield;\n  }\n};\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br")])]),s("p",[n._v("上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量"),s("code",[n._v("ticking")]),n._v("，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。")]),n._v(" "),s("h3",{attrs:{id:"generator-与协程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generator-与协程"}},[n._v("#")]),n._v(" Generator 与协程")]),n._v(" "),s("p",[n._v("协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。")]),n._v(" "),s("p",[s("strong",[n._v("（1）协程与子例程的差异")])]),n._v(" "),s("p",[n._v("传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。")]),n._v(" "),s("p",[n._v("从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。")]),n._v(" "),s("p",[s("strong",[n._v("（2）协程与普通线程的差异")])]),n._v(" "),s("p",[n._v("不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。")]),n._v(" "),s("p",[n._v("由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。")]),n._v(" "),s("p",[n._v("Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。")]),n._v(" "),s("p",[n._v("如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用"),s("code",[n._v("yield")]),n._v("表达式交换控制权。")]),n._v(" "),s("h3",{attrs:{id:"generator-与上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generator-与上下文"}},[n._v("#")]),n._v(" Generator 与上下文")]),n._v(" "),s("p",[n._v("JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。")]),n._v(" "),s("p",[n._v("这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。")]),n._v(" "),s("p",[n._v("Generator 函数不是这样，它执行产生的上下文环境，一旦遇到"),s("code",[n._v("yield")]),n._v("命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行"),s("code",[n._v("next")]),n._v("命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* gen() {\n  yield 1;\n  return 2;\n}\n\nlet g = gen();\n\nconsole.log(\n  g.next().value,\n  g.next().value,\n);\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br")])]),s("p",[n._v("上面代码中，第一次执行"),s("code",[n._v("g.next()")]),n._v("时，Generator 函数"),s("code",[n._v("gen")]),n._v("的上下文会加入堆栈，即开始运行"),s("code",[n._v("gen")]),n._v("内部的代码。等遇到"),s("code",[n._v("yield 1")]),n._v("时，"),s("code",[n._v("gen")]),n._v("上下文退出堆栈，内部状态冻结。第二次执行"),s("code",[n._v("g.next()")]),n._v("时，"),s("code",[n._v("gen")]),n._v("上下文重新加入堆栈，变成当前的上下文，重新恢复执行。")]),n._v(" "),s("h2",{attrs:{id:"应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[n._v("#")]),n._v(" 应用")]),n._v(" "),s("p",[n._v("Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。")]),n._v(" "),s("h3",{attrs:{id:"_1-异步操作的同步化表达"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-异步操作的同步化表达"}},[n._v("#")]),n._v(" （1）异步操作的同步化表达")]),n._v(" "),s("p",[n._v("Generator 函数的暂停执行的效果，意味着可以把异步操作写在"),s("code",[n._v("yield")]),n._v("表达式里面，等到调用"),s("code",[n._v("next")]),n._v("方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在"),s("code",[n._v("yield")]),n._v("表达式下面，反正要等到调用"),s("code",[n._v("next")]),n._v("方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* loadUI() {\n  showLoadingScreen();\n  yield loadUIDataAsynchronously();\n  hideLoadingScreen();\n}\nvar loader = loadUI();\n// 加载UI\nloader.next()\n\n// 卸载UI\nloader.next()\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br")])]),s("p",[n._v("上面代码中，第一次调用"),s("code",[n._v("loadUI")]),n._v("函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用"),s("code",[n._v("next")]),n._v("方法，则会显示"),s("code",[n._v("Loading")]),n._v("界面（"),s("code",[n._v("showLoadingScreen")]),n._v("），并且异步加载数据（"),s("code",[n._v("loadUIDataAsynchronously")]),n._v("）。等到数据加载完成，再一次使用"),s("code",[n._v("next")]),n._v("方法，则会隐藏"),s("code",[n._v("Loading")]),n._v("界面。可以看到，这种写法的好处是所有"),s("code",[n._v("Loading")]),n._v("界面的逻辑，都被封装在一个函数，按部就班非常清晰。")]),n._v(" "),s("p",[n._v("Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('function* main() {\n  var result = yield request("http://some.url");\n  var resp = JSON.parse(result);\n    console.log(resp.value);\n}\n\nfunction request(url) {\n  makeAjaxCall(url, function(response){\n    it.next(response);\n  });\n}\n\nvar it = main();\nit.next();\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br")])]),s("p",[n._v("上面代码的"),s("code",[n._v("main")]),n._v("函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个"),s("code",[n._v("yield")]),n._v("，它几乎与同步操作的写法完全一样。注意，"),s("code",[n._v("makeAjaxCall")]),n._v("函数中的"),s("code",[n._v("next")]),n._v("方法，必须加上"),s("code",[n._v("response")]),n._v("参数，因为"),s("code",[n._v("yield")]),n._v("表达式，本身是没有值的，总是等于"),s("code",[n._v("undefined")]),n._v("。")]),n._v(" "),s("p",[n._v("下面是另一个例子，通过 Generator 函数逐行读取文本文件。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('function* numbers() {\n  let file = new FileReader("numbers.txt");\n  try {\n    while(!file.eof) {\n      yield parseInt(file.readLine(), 10);\n    }\n  } finally {\n    file.close();\n  }\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br")])]),s("p",[n._v("上面代码打开文本文件，使用"),s("code",[n._v("yield")]),n._v("表达式可以手动逐行读取文件。")]),n._v(" "),s("h3",{attrs:{id:"_2-控制流管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-控制流管理"}},[n._v("#")]),n._v(" （2）控制流管理")]),n._v(" "),s("p",[n._v("如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("step1(function (value1) {\n  step2(value1, function(value2) {\n    step3(value2, function(value3) {\n      step4(value3, function(value4) {\n        // Do something with value4\n      });\n    });\n  });\n});\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br")])]),s("p",[n._v("采用 Promise 改写上面的代码。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("Promise.resolve(step1)\n  .then(step2)\n  .then(step3)\n  .then(step4)\n  .then(function (value4) {\n    // Do something with value4\n  }, function (error) {\n    // Handle any error from step1 through step4\n  })\n  .done();\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br")])]),s("p",[n._v("上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* longRunningTask(value1) {\n  try {\n    var value2 = yield step1(value1);\n    var value3 = yield step2(value2);\n    var value4 = yield step3(value3);\n    var value5 = yield step4(value4);\n    // Do something with value4\n  } catch (e) {\n    // Handle any error from step1 through step4\n  }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br")])]),s("p",[n._v("然后，使用一个函数，按次序自动执行所有步骤。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("scheduler(longRunningTask(initialValue));\n\nfunction scheduler(task) {\n  var taskObj = task.next(task.value);\n  // 如果Generator函数未结束，就继续调用\n  if (!taskObj.done) {\n    task.value = taskObj.value\n    scheduler(task);\n  }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br")])]),s("p",[n._v("注意，上面这种做法，只适合同步操作，即所有的"),s("code",[n._v("task")]),n._v("都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。")]),n._v(" "),s("p",[n._v("下面，利用"),s("code",[n._v("for...of")]),n._v("循环会自动依次执行"),s("code",[n._v("yield")]),n._v("命令的特性，提供一种更一般的控制流管理的方法。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("let steps = [step1Func, step2Func, step3Func];\n\nfunction* iterateSteps(steps){\n  for (var i=0; i< steps.length; i++){\n    var step = steps[i];\n    yield step();\n  }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br")])]),s("p",[n._v("上面代码中，数组"),s("code",[n._v("steps")]),n._v("封装了一个任务的多个步骤，Generator 函数"),s("code",[n._v("iterateSteps")]),n._v("则是依次为这些步骤加上"),s("code",[n._v("yield")]),n._v("命令。")]),n._v(" "),s("p",[n._v("将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("let jobs = [job1, job2, job3];\n\nfunction* iterateJobs(jobs){\n  for (var i=0; i< jobs.length; i++){\n    var job = jobs[i];\n    yield* iterateSteps(job.steps);\n  }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br")])]),s("p",[n._v("上面代码中，数组"),s("code",[n._v("jobs")]),n._v("封装了一个项目的多个任务，Generator 函数"),s("code",[n._v("iterateJobs")]),n._v("则是依次为这些任务加上"),s("code",[n._v("yield*")]),n._v("命令。")]),n._v(" "),s("p",[n._v("最后，就可以用"),s("code",[n._v("for...of")]),n._v("循环一次性依次执行所有任务的所有步骤。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("for (var step of iterateJobs(jobs)){\n  console.log(step.id);\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br")])]),s("p",[n._v("再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。")]),n._v(" "),s("p",[s("code",[n._v("for...of")]),n._v("的本质是一个"),s("code",[n._v("while")]),n._v("循环，所以上面的代码实质上执行的是下面的逻辑。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var it = iterateJobs(jobs);\nvar res = it.next();\n\nwhile (!res.done){\n  var result = res.value;\n  // ...\n  res = it.next();\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br")])]),s("h3",{attrs:{id:"_3-部署-iterator-接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-部署-iterator-接口"}},[n._v("#")]),n._v(" （3）部署 Iterator 接口")]),n._v(" "),s("p",[n._v("利用 Generator 函数，可以在任意对象上部署 Iterator 接口。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* iterEntries(obj) {\n  let keys = Object.keys(obj);\n  for (let i=0; i < keys.length; i++) {\n    let key = keys[i];\n    yield [key, obj[key]];\n  }\n}\n\nlet myObj = { foo: 3, bar: 7 };\n\nfor (let [key, value] of iterEntries(myObj)) {\n  console.log(key, value);\n}\n\n// foo 3\n// bar 7\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br")])]),s("p",[n._v("上述代码中，"),s("code",[n._v("myObj")]),n._v("是一个普通对象，通过"),s("code",[n._v("iterEntries")]),n._v("函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署"),s("code",[n._v("next")]),n._v("方法。")]),n._v(" "),s("p",[n._v("下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* makeSimpleGenerator(array){\n  var nextIndex = 0;\n\n  while(nextIndex < array.length){\n    yield array[nextIndex++];\n  }\n}\n\nvar gen = makeSimpleGenerator(['yo', 'ya']);\n\ngen.next().value // 'yo'\ngen.next().value // 'ya'\ngen.next().done  // true\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br")])]),s("h3",{attrs:{id:"_4-作为数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-作为数据结构"}},[n._v("#")]),n._v(" （4）作为数据结构")]),n._v(" "),s("p",[n._v("Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function* doStuff() {\n  yield fs.readFile.bind(null, 'hello.txt');\n  yield fs.readFile.bind(null, 'world.txt');\n  yield fs.readFile.bind(null, 'and-such.txt');\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br")])]),s("p",[n._v("上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("for (task of doStuff()) {\n  // task是一个函数，可以像回调函数那样使用它\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br")])]),s("p",[n._v("实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function doStuff() {\n  return [\n    fs.readFile.bind(null, 'hello.txt'),\n    fs.readFile.bind(null, 'world.txt'),\n    fs.readFile.bind(null, 'and-such.txt')\n  ];\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br")])]),s("p",[n._v("上面的函数，可以用一模一样的"),s("code",[n._v("for...of")]),n._v("循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。")]),n._v(" "),s("h3",{attrs:{id:"留言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#留言"}},[n._v("#")]),n._v(" 留言")])])}),[],!1,null,null,null);e.default=t.exports}}]);
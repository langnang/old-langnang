(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{531:function(e,s,a){"use strict";a.r(s);var n=a(18),t=Object(n.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"正则的扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#正则的扩展"}},[e._v("#")]),e._v(" 正则的扩展")]),e._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#RegExp%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",target:"_blank",rel:"noopener noreferrer"}},[e._v("RegExp 构造函数"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AD%A3%E5%88%99%E6%96%B9%E6%B3%95",target:"_blank",rel:"noopener noreferrer"}},[e._v("字符串的正则方法"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#u%20%E4%BF%AE%E9%A5%B0%E7%AC%A6",target:"_blank",rel:"noopener noreferrer"}},[e._v("u 修饰符"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#RegExp.prototype.unicode%20%E5%B1%9E%E6%80%A7",target:"_blank",rel:"noopener noreferrer"}},[e._v("RegExp.prototype.unicode 属性"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#y%20%E4%BF%AE%E9%A5%B0%E7%AC%A6",target:"_blank",rel:"noopener noreferrer"}},[e._v("y 修饰符"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#RegExp.prototype.sticky%20%E5%B1%9E%E6%80%A7",target:"_blank",rel:"noopener noreferrer"}},[e._v("RegExp.prototype.sticky 属性"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#RegExp.prototype.flags%20%E5%B1%9E%E6%80%A7",target:"_blank",rel:"noopener noreferrer"}},[e._v("RegExp.prototype.flags 属性"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#s%20%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9AdotAll%20%E6%A8%A1%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"}},[e._v("s 修饰符：dotAll 模式"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80",target:"_blank",rel:"noopener noreferrer"}},[e._v("后行断言"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#Unicode%20%E5%B1%9E%E6%80%A7%E7%B1%BB",target:"_blank",rel:"noopener noreferrer"}},[e._v("Unicode 属性类"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#v%20%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9AUnicode%20%E5%B1%9E%E6%80%A7%E7%B1%BB%E7%9A%84%E8%BF%90%E7%AE%97",target:"_blank",rel:"noopener noreferrer"}},[e._v("v 修饰符：Unicode 属性类的运算"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#%E5%85%B7%E5%90%8D%E7%BB%84%E5%8C%B9%E9%85%8D",target:"_blank",rel:"noopener noreferrer"}},[e._v("具名组匹配"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#d%20%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%B4%A2%E5%BC%95",target:"_blank",rel:"noopener noreferrer"}},[e._v("d 修饰符：正则匹配索引"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/regex#String.prototype.matchAll()",target:"_blank",rel:"noopener noreferrer"}},[e._v("String.prototype.matchAll()"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"regexp-构造函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#regexp-构造函数"}},[e._v("#")]),e._v(" RegExp 构造函数")]),e._v(" "),a("p",[e._v("在 ES5 中，"),a("code",[e._v("RegExp")]),e._v("构造函数的参数有两种情况。")]),e._v(" "),a("p",[e._v("第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var regex = new RegExp('xyz', 'i');\n// 等价于\nvar regex = /xyz/i;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var regex = new RegExp(/xyz/i);\n// 等价于\nvar regex = /xyz/i;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var regex = new RegExp(/xyz/, 'i');\n// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("ES6 改变了这种行为。如果"),a("code",[e._v("RegExp")]),e._v("构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("new RegExp(/abc/ig, 'i').flags\n// \"i\"\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面代码中，原有正则对象的修饰符是"),a("code",[e._v("ig")]),e._v("，它会被第二个参数"),a("code",[e._v("i")]),e._v("覆盖。")]),e._v(" "),a("h2",{attrs:{id:"字符串的正则方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串的正则方法"}},[e._v("#")]),e._v(" 字符串的正则方法")]),e._v(" "),a("p",[e._v("ES6 出现之前，字符串对象共有 4 个方法，可以使用正则表达式："),a("code",[e._v("match()")]),e._v("、"),a("code",[e._v("replace()")]),e._v("、"),a("code",[e._v("search()")]),e._v("和"),a("code",[e._v("split()")]),e._v("。")]),e._v(" "),a("p",[e._v("ES6 将这 4 个方法，在语言内部全部调用"),a("code",[e._v("RegExp")]),e._v("的实例方法，从而做到所有与正则相关的方法，全都定义在"),a("code",[e._v("RegExp")]),e._v("对象上。")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("String.prototype.match")]),e._v(" 调用 "),a("code",[e._v("RegExp.prototype[Symbol.match]")])]),e._v(" "),a("li",[a("code",[e._v("String.prototype.replace")]),e._v(" 调用 "),a("code",[e._v("RegExp.prototype[Symbol.replace]")])]),e._v(" "),a("li",[a("code",[e._v("String.prototype.search")]),e._v(" 调用 "),a("code",[e._v("RegExp.prototype[Symbol.search]")])]),e._v(" "),a("li",[a("code",[e._v("String.prototype.split")]),e._v(" 调用 "),a("code",[e._v("RegExp.prototype[Symbol.split]")])])]),e._v(" "),a("h2",{attrs:{id:"u-修饰符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#u-修饰符"}},[e._v("#")]),e._v(" u 修饰符")]),e._v(" "),a("p",[e._v("ES6 对正则表达式添加了"),a("code",[e._v("u")]),e._v("修饰符，含义为“Unicode 模式”，用来正确处理大于"),a("code",[e._v("\\uFFFF")]),e._v("的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/^\\uD83D/u.test('\\uD83D\\uDC2A') // false\n/^\\uD83D/.test('\\uD83D\\uDC2A') // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面代码中，"),a("code",[e._v("\\uD83D\\uDC2A")]),e._v("是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为"),a("code",[e._v("true")]),e._v("。加了"),a("code",[e._v("u")]),e._v("修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为"),a("code",[e._v("false")]),e._v("。")]),e._v(" "),a("p",[e._v("一旦加上"),a("code",[e._v("u")]),e._v("修饰符号，就会修改下面这些正则表达式的行为。")]),e._v(" "),a("p",[a("strong",[e._v("（1）点字符")])]),e._v(" "),a("p",[e._v("点（"),a("code",[e._v(".")]),e._v("）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于"),a("code",[e._v("0xFFFF")]),e._v("的 Unicode 字符，点字符不能识别，必须加上"),a("code",[e._v("u")]),e._v("修饰符。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var s = '𠮷';\n\n/^.$/.test(s) // false\n/^.$/u.test(s) // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("上面代码表示，如果不添加"),a("code",[e._v("u")]),e._v("修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。")]),e._v(" "),a("p",[a("strong",[e._v("（2）Unicode 字符表示法")])]),e._v(" "),a("p",[e._v("ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上"),a("code",[e._v("u")]),e._v("修饰符，才能识别当中的大括号，否则会被解读为量词。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/\\u{61}/.test('a') // false\n/\\u{61}/u.test('a') // true\n/\\u{20BB7}/u.test('𠮷') // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("上面代码表示，如果不加"),a("code",[e._v("u")]),e._v("修饰符，正则表达式无法识别"),a("code",[e._v("\\u{61}")]),e._v("这种表示法，只会认为这匹配 61 个连续的"),a("code",[e._v("u")]),e._v("。")]),e._v(" "),a("p",[a("strong",[e._v("（3）量词")])]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("u")]),e._v("修饰符后，所有量词都会正确识别码点大于"),a("code",[e._v("0xFFFF")]),e._v("的 Unicode 字符。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/a{2}/.test('aa') // true\n/a{2}/u.test('aa') // true\n/𠮷{2}/.test('𠮷𠮷') // false\n/𠮷{2}/u.test('𠮷𠮷') // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[a("strong",[e._v("（4）预定义模式")])]),e._v(" "),a("p",[a("code",[e._v("u")]),e._v("修饰符也影响到预定义模式，能否正确识别码点大于"),a("code",[e._v("0xFFFF")]),e._v("的 Unicode 字符。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/^\\S$/.test('𠮷') // false\n/^\\S$/u.test('𠮷') // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面代码的"),a("code",[e._v("\\S")]),e._v("是预定义模式，匹配所有非空白字符。只有加了"),a("code",[e._v("u")]),e._v("修饰符，它才能正确匹配码点大于"),a("code",[e._v("0xFFFF")]),e._v("的 Unicode 字符。")]),e._v(" "),a("p",[e._v("利用这一点，可以写出一个正确返回字符串长度的函数。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function codePointLength(text) {\n  var result = text.match(/[\\s\\S]/gu);\n  return result ? result.length : 0;\n}\n\nvar s = '𠮷𠮷';\n\ns.length // 4\ncodePointLength(s) // 2\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[a("strong",[e._v("（5）i 修饰符")])]),e._v(" "),a("p",[e._v("有些 Unicode 字符的编码不同，但是字型很相近，比如，"),a("code",[e._v("\\u004B")]),e._v("与"),a("code",[e._v("\\u212A")]),e._v("都是大写的"),a("code",[e._v("K")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/[a-z]/i.test('\\u212A') // false\n/[a-z]/iu.test('\\u212A') // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面代码中，不加"),a("code",[e._v("u")]),e._v("修饰符，就无法识别非规范的"),a("code",[e._v("K")]),e._v("字符。")]),e._v(" "),a("p",[a("strong",[e._v("（6）转义")])]),e._v(" "),a("p",[e._v("没有"),a("code",[e._v("u")]),e._v("修饰符的情况下，正则中没有定义的转义（如逗号的转义"),a("code",[e._v("\\,")]),e._v("）无效，而在"),a("code",[e._v("u")]),e._v("模式会报错。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/\\,/ // /\\,/\n/\\,/u // 报错\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面代码中，没有"),a("code",[e._v("u")]),e._v("修饰符时，逗号前面的反斜杠是无效的，加了"),a("code",[e._v("u")]),e._v("修饰符就报错。")]),e._v(" "),a("h2",{attrs:{id:"regexp-prototype-unicode-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#regexp-prototype-unicode-属性"}},[e._v("#")]),e._v(" RegExp.prototype.unicode 属性")]),e._v(" "),a("p",[e._v("正则实例对象新增"),a("code",[e._v("unicode")]),e._v("属性，表示是否设置了"),a("code",[e._v("u")]),e._v("修饰符。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const r1 = /hello/;\nconst r2 = /hello/u;\n\nr1.unicode // false\nr2.unicode // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("上面代码中，正则表达式是否设置了"),a("code",[e._v("u")]),e._v("修饰符，可以从"),a("code",[e._v("unicode")]),e._v("属性看出来。")]),e._v(" "),a("h2",{attrs:{id:"y-修饰符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#y-修饰符"}},[e._v("#")]),e._v(" y 修饰符")]),e._v(" "),a("p",[e._v("除了"),a("code",[e._v("u")]),e._v("修饰符，ES6 还为正则表达式添加了"),a("code",[e._v("y")]),e._v("修饰符，叫做“粘连”（sticky）修饰符。")]),e._v(" "),a("p",[a("code",[e._v("y")]),e._v("修饰符的作用与"),a("code",[e._v("g")]),e._v("修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，"),a("code",[e._v("g")]),e._v("修饰符只要剩余位置中存在匹配就可，而"),a("code",[e._v("y")]),e._v("修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('var s = \'aaa_aa_a\';\nvar r1 = /a+/g;\nvar r2 = /a+/y;\n\nr1.exec(s) // ["aaa"]\nr2.exec(s) // ["aaa"]\n\nr1.exec(s) // ["aa"]\nr2.exec(s) // null\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[e._v("上面代码有两个正则表达式，一个使用"),a("code",[e._v("g")]),e._v("修饰符，另一个使用"),a("code",[e._v("y")]),e._v("修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是"),a("code",[e._v("_aa_a")]),e._v("。由于"),a("code",[e._v("g")]),e._v("修饰没有位置要求，所以第二次执行会返回结果，而"),a("code",[e._v("y")]),e._v("修饰符要求匹配必须从头部开始，所以返回"),a("code",[e._v("null")]),e._v("。")]),e._v(" "),a("p",[e._v("如果改一下正则表达式，保证每次都能头部匹配，"),a("code",[e._v("y")]),e._v("修饰符就会返回结果了。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('var s = \'aaa_aa_a\';\nvar r = /a+_/y;\n\nr.exec(s) // ["aaa_"]\nr.exec(s) // ["aa_"]\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("上面代码每次匹配，都是从剩余字符串的头部开始。")]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("lastIndex")]),e._v("属性，可以更好地说明"),a("code",[e._v("y")]),e._v("修饰符。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const REGEX = /a/g;\n\n// 指定从2号位置（y）开始匹配\nREGEX.lastIndex = 2;\n\n// 匹配成功\nconst match = REGEX.exec('xaya');\n\n// 在3号位置匹配成功\nmatch.index // 3\n\n// 下一次匹配从4号位开始\nREGEX.lastIndex // 4\n\n// 4号位开始匹配失败\nREGEX.exec('xaya') // null\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br")])]),a("p",[e._v("上面代码中，"),a("code",[e._v("lastIndex")]),e._v("属性指定每次搜索的开始位置，"),a("code",[e._v("g")]),e._v("修饰符从这个位置开始向后搜索，直到发现匹配为止。")]),e._v(" "),a("p",[a("code",[e._v("y")]),e._v("修饰符同样遵守"),a("code",[e._v("lastIndex")]),e._v("属性，但是要求必须在"),a("code",[e._v("lastIndex")]),e._v("指定的位置发现匹配。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const REGEX = /a/y;\n\n// 指定从2号位置开始匹配\nREGEX.lastIndex = 2;\n\n// 不是粘连，匹配失败\nREGEX.exec('xaya') // null\n\n// 指定从3号位置开始匹配\nREGEX.lastIndex = 3;\n\n// 3号位置是粘连，匹配成功\nconst match = REGEX.exec('xaya');\nmatch.index // 3\nREGEX.lastIndex // 4\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br")])]),a("p",[e._v("实际上，"),a("code",[e._v("y")]),e._v("修饰符号隐含了头部匹配的标志"),a("code",[e._v("^")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/b/y.exec('aba')\n// null\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面代码由于不能保证头部匹配，所以返回"),a("code",[e._v("null")]),e._v("。"),a("code",[e._v("y")]),e._v("修饰符的设计本意，就是让头部匹配的标志"),a("code",[e._v("^")]),e._v("在全局匹配中都有效。")]),e._v(" "),a("p",[e._v("下面是字符串对象的"),a("code",[e._v("replace")]),e._v("方法的例子。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const REGEX = /a/gy;\n'aaxa'.replace(REGEX, '-') // '--xa'\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面代码中，最后一个"),a("code",[e._v("a")]),e._v("因为不是出现在下一次匹配的头部，所以不会被替换。")]),e._v(" "),a("p",[e._v("单单一个"),a("code",[e._v("y")]),e._v("修饰符对"),a("code",[e._v("match")]),e._v("方法，只能返回第一个匹配，必须与"),a("code",[e._v("g")]),e._v("修饰符联用，才能返回所有匹配。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('\'a1a2a3\'.match(/a\\d/y) // ["a1"]\n\'a1a2a3\'.match(/a\\d/gy) // ["a1", "a2", "a3"]\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[a("code",[e._v("y")]),e._v("修饰符的一个应用，是从字符串提取 token（词元），"),a("code",[e._v("y")]),e._v("修饰符确保了匹配之间不会有漏掉的字符。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const TOKEN_Y = /\\s*(\\+|[0-9]+)\\s*/y;\nconst TOKEN_G  = /\\s*(\\+|[0-9]+)\\s*/g;\n\ntokenize(TOKEN_Y, '3 + 4')\n// [ '3', '+', '4' ]\ntokenize(TOKEN_G, '3 + 4')\n// [ '3', '+', '4' ]\n\nfunction tokenize(TOKEN_REGEX, str) {\n  let result = [];\n  let match;\n  while (match = TOKEN_REGEX.exec(str)) {\n    result.push(match[1]);\n  }\n  return result;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br")])]),a("p",[e._v("上面代码中，如果字符串里面没有非法字符，"),a("code",[e._v("y")]),e._v("修饰符与"),a("code",[e._v("g")]),e._v("修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("tokenize(TOKEN_Y, '3x + 4')\n// [ '3' ]\ntokenize(TOKEN_G, '3x + 4')\n// [ '3', '+', '4' ]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("上面代码中，"),a("code",[e._v("g")]),e._v("修饰符会忽略非法字符，而"),a("code",[e._v("y")]),e._v("修饰符不会，这样就很容易发现错误。")]),e._v(" "),a("h2",{attrs:{id:"regexp-prototype-sticky-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#regexp-prototype-sticky-属性"}},[e._v("#")]),e._v(" RegExp.prototype.sticky 属性")]),e._v(" "),a("p",[e._v("与"),a("code",[e._v("y")]),e._v("修饰符相匹配，ES6 的正则实例对象多了"),a("code",[e._v("sticky")]),e._v("属性，表示是否设置了"),a("code",[e._v("y")]),e._v("修饰符。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var r = /hello\\d/y;\nr.sticky // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("h2",{attrs:{id:"regexp-prototype-flags-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#regexp-prototype-flags-属性"}},[e._v("#")]),e._v(" RegExp.prototype.flags 属性")]),e._v(" "),a("p",[e._v("ES6 为正则表达式新增了"),a("code",[e._v("flags")]),e._v("属性，会返回正则表达式的修饰符。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// ES5 的 source 属性\n// 返回正则表达式的正文\n/abc/ig.source\n// \"abc\"\n\n// ES6 的 flags 属性\n// 返回正则表达式的修饰符\n/abc/ig.flags\n// 'gi'\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("h2",{attrs:{id:"s-修饰符-dotall-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#s-修饰符-dotall-模式"}},[e._v("#")]),e._v(" s 修饰符：dotAll 模式")]),e._v(" "),a("p",[e._v("正则表达式中，点（"),a("code",[e._v(".")]),e._v("）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用"),a("code",[e._v("u")]),e._v("修饰符解决；另一个是行终止符（line terminator character）。")]),e._v(" "),a("p",[e._v("所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。")]),e._v(" "),a("ul",[a("li",[e._v("U+000A 换行符（"),a("code",[e._v("\\n")]),e._v("）")]),e._v(" "),a("li",[e._v("U+000D 回车符（"),a("code",[e._v("\\r")]),e._v("）")]),e._v(" "),a("li",[e._v("U+2028 行分隔符（line separator）")]),e._v(" "),a("li",[e._v("U+2029 段分隔符（paragraph separator）")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/foo.bar/.test('foo\\nbar')\n// false\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面代码中，因为"),a("code",[e._v(".")]),e._v("不匹配"),a("code",[e._v("\\n")]),e._v("，所以正则表达式返回"),a("code",[e._v("false")]),e._v("。")]),e._v(" "),a("p",[e._v("但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/foo[^]bar/.test('foo\\nbar')\n// true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("这种解决方案毕竟不太符合直觉，ES2018 "),a("a",{attrs:{href:"https://github.com/tc39/proposal-regexp-dotall-flag",target:"_blank",rel:"noopener noreferrer"}},[e._v("引入"),a("OutboundLink")],1),a("code",[e._v("s")]),e._v("修饰符，使得"),a("code",[e._v(".")]),e._v("可以匹配任意单个字符。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/foo.bar/s.test('foo\\nbar') // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("这被称为"),a("code",[e._v("dotAll")]),e._v("模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个"),a("code",[e._v("dotAll")]),e._v("属性，返回一个布尔值，表示该正则表达式是否处在"),a("code",[e._v("dotAll")]),e._v("模式。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const re = /foo.bar/s;\n// 另一种写法\n// const re = new RegExp('foo.bar', 's');\n\nre.test('foo\\nbar') // true\nre.dotAll // true\nre.flags // 's'\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("p",[a("code",[e._v("/s")]),e._v("修饰符和多行修饰符"),a("code",[e._v("/m")]),e._v("不冲突，两者一起使用的情况下，"),a("code",[e._v(".")]),e._v("匹配所有字符，而"),a("code",[e._v("^")]),e._v("和"),a("code",[e._v("$")]),e._v("匹配每一行的行首和行尾。")]),e._v(" "),a("h2",{attrs:{id:"后行断言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#后行断言"}},[e._v("#")]),e._v(" 后行断言")]),e._v(" "),a("p",[e._v("JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入"),a("a",{attrs:{href:"https://github.com/tc39/proposal-regexp-lookbehind",target:"_blank",rel:"noopener noreferrer"}},[e._v("后行断言"),a("OutboundLink")],1),e._v("，V8 引擎 4.9 版（Chrome 62）已经支持。")]),e._v(" "),a("p",[e._v("“先行断言”指的是，"),a("code",[e._v("x")]),e._v("只有在"),a("code",[e._v("y")]),e._v("前面才匹配，必须写成"),a("code",[e._v("/x(?=y)/")]),e._v("。比如，只匹配百分号之前的数字，要写成"),a("code",[e._v("/\\d+(?=%)/")]),e._v("。“先行否定断言”指的是，"),a("code",[e._v("x")]),e._v("只有不在"),a("code",[e._v("y")]),e._v("前面才匹配，必须写成"),a("code",[e._v("/x(?!y)/")]),e._v("。比如，只匹配不在百分号之前的数字，要写成"),a("code",[e._v("/\\d+(?!%)/")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/\\d+(?=%)/.exec('100% of US presidents have been male')  // [\"100\"]\n/\\d+(?!%)/.exec('that’s all 44 of them')                 // [\"44\"]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（"),a("code",[e._v("(?=%)")]),e._v("），是不计入返回结果的。")]),e._v(" "),a("p",[e._v("“后行断言”正好与“先行断言”相反，"),a("code",[e._v("x")]),e._v("只有在"),a("code",[e._v("y")]),e._v("后面才匹配，必须写成"),a("code",[e._v("/(?<=y)x/")]),e._v("。比如，只匹配美元符号之后的数字，要写成"),a("code",[e._v("/(?<=\\$)\\d+/")]),e._v("。“后行否定断言”则与“先行否定断言”相反，"),a("code",[e._v("x")]),e._v("只有不在"),a("code",[e._v("y")]),e._v("后面才匹配，必须写成"),a("code",[e._v("/(?<!y)x/")]),e._v("。比如，只匹配不在美元符号后面的数字，要写成"),a("code",[e._v("/(?<!\\$)\\d+/")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/(?<=\\$)\\d+/.exec('Benjamin Franklin is on the $100 bill')  // [\"100\"]\n/(?<!\\$)\\d+/.exec('it’s is worth about €90')                // [\"90\"]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面的例子中，“后行断言”的括号之中的部分（"),a("code",[e._v("(?<=\\$)")]),e._v("），也是不计入返回结果。")]),e._v(" "),a("p",[e._v("下面的例子是使用后行断言进行字符串替换。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const RE_DOLLAR_PREFIX = /(?<=\\$)foo/g;\n'$foo %foo foo'.replace(RE_DOLLAR_PREFIX, 'bar');\n// '$bar %foo foo'\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("上面代码中，只有在美元符号后面的"),a("code",[e._v("foo")]),e._v("才会被替换。")]),e._v(" "),a("p",[e._v("“后行断言”的实现，需要先匹配"),a("code",[e._v("/(?<=y)x/")]),e._v("的"),a("code",[e._v("x")]),e._v("，然后再回到左边，匹配"),a("code",[e._v("y")]),e._v("的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。")]),e._v(" "),a("p",[e._v("首先，后行断言的组匹配，与正常情况下结果是不一样的。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('/(?<=(\\d+)(\\d+))$/.exec(\'1053\') // ["", "1", "053"]\n/^(\\d+)(\\d+)$/.exec(\'1053\') // ["1053", "105", "3"]\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是"),a("code",[e._v("105")]),e._v("和"),a("code",[e._v("3")]),e._v("。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是"),a("code",[e._v("1")]),e._v("和"),a("code",[e._v("053")]),e._v("。")]),e._v(" "),a("p",[e._v("其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/(?<=(o)d\\1)r/.exec('hodor')  // null\n/(?<=\\1d(o))r/.exec('hodor')  // [\"r\", \"o\"]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面代码中，如果后行断言的反斜杠引用（"),a("code",[e._v("\\1")]),e._v("）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。")]),e._v(" "),a("h2",{attrs:{id:"unicode-属性类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unicode-属性类"}},[e._v("#")]),e._v(" Unicode 属性类")]),e._v(" "),a("p",[e._v("ES2018 "),a("a",{attrs:{href:"https://github.com/tc39/proposal-regexp-unicode-property-escapes",target:"_blank",rel:"noopener noreferrer"}},[e._v("引入"),a("OutboundLink")],1),e._v("了 Unicode 属性类，允许使用"),a("code",[e._v("\\p{...}")]),e._v("和"),a("code",[e._v("\\P{...}")]),e._v("（"),a("code",[e._v("\\P")]),e._v("是"),a("code",[e._v("\\p")]),e._v("的否定形式）代表一类 Unicode 字符，匹配满足条件的所有字符。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const regexGreekSymbol = /\\p{Script=Greek}/u;\nregexGreekSymbol.test('π') // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面代码中，"),a("code",[e._v("\\p{Script=Greek}")]),e._v("表示匹配一个希腊文字母，所以匹配"),a("code",[e._v("π")]),e._v("成功。")]),e._v(" "),a("p",[e._v("Unicode 属性类的标准形式，需要同时指定属性名和属性值。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\\p{UnicodePropertyName=UnicodePropertyValue}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("但是，对于某些属性，可以只写属性名，或者只写属性值。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\\p{UnicodePropertyName}\n\\p{UnicodePropertyValue}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[a("code",[e._v("\\P{…}")]),e._v("是"),a("code",[e._v("\\p{…}")]),e._v("的反向匹配，即匹配不满足条件的字符。")]),e._v(" "),a("p",[e._v("注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上"),a("code",[e._v("u")]),e._v("修饰符。如果不加"),a("code",[e._v("u")]),e._v("修饰符，正则表达式使用"),a("code",[e._v("\\p")]),e._v("和"),a("code",[e._v("\\P")]),e._v("会报错。")]),e._v(" "),a("p",[e._v("由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const regex = /^\\p{Decimal_Number}+$/u;\nregex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。")]),e._v(" "),a("p",[a("code",[e._v("\\p{Number}")]),e._v("甚至能匹配罗马数字。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 匹配所有数字\nconst regex = /^\\p{Number}+$/u;\nregex.test('²³¹¼½¾') // true\nregex.test('㉛㉜㉝') // true\nregex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("下面是其他一些例子。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 匹配所有空格\n\\p{White_Space}\n\n// 匹配各种文字的所有字母，等同于 Unicode 版的 \\w\n[\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]\n\n// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W\n[^\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]\n\n// 匹配 Emoji\n/\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F/gu\n\n// 匹配所有的箭头字符\nconst regexArrows = /^\\p{Block=Arrows}+$/u;\nregexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br")])]),a("h2",{attrs:{id:"v-修饰符-unicode-属性类的运算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-修饰符-unicode-属性类的运算"}},[e._v("#")]),e._v(" v 修饰符：Unicode 属性类的运算")]),e._v(" "),a("p",[e._v("有时，需要向某个 Unicode 属性类添加或减少字符，即需要对属性类进行运算。现在有一个"),a("a",{attrs:{href:"https://github.com/tc39/proposal-regexp-v-flag",target:"_blank",rel:"noopener noreferrer"}},[e._v("提案"),a("OutboundLink")],1),e._v("，增加了 Unicode 属性类的运算功能。")]),e._v(" "),a("p",[e._v("它提供两种形式的运算，一种是差集运算（A 集合减去 B 集合），另一种是交集运算。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 差集运算（A 减去 B）\n[A--B]\n\n// 交集运算（A 与 B 的交集）\n[A&&B]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("上面两种写法中，A 和 B 要么是字符类（例如"),a("code",[e._v("[a-z]")]),e._v("），要么是 Unicode 属性类（例如"),a("code",[e._v("\\p{ASCII}")]),e._v("）。")]),e._v(" "),a("p",[e._v("而且，这种运算支持方括号之中嵌入方括号，即方括号的嵌套。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 方括号嵌套的例子\n[A--[0-9]]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("这种运算的前提是，正则表达式必须使用新引入的"),a("code",[e._v("v")]),e._v("修饰符。前面说过，Unicode 属性类必须搭配"),a("code",[e._v("u")]),e._v("修饰符使用，这个"),a("code",[e._v("v")]),e._v("修饰符等于代替"),a("code",[e._v("u")]),e._v("，使用了它就不必再写"),a("code",[e._v("u")]),e._v("了。")]),e._v(" "),a("p",[e._v("下面是一些例子。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 十进制字符去除 ASCII 码的0到9\n[\\p{Decimal_Number}--[0-9]]\n\n// Emoji 字符去除 ASCII 码字符\n[\\p{Emoji}--\\p{ASCII}]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("h2",{attrs:{id:"具名组匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#具名组匹配"}},[e._v("#")]),e._v(" 具名组匹配")]),e._v(" "),a("h3",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),a("p",[e._v("正则表达式使用圆括号进行组匹配。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("上面代码中，正则表达式里面有三组圆括号。使用"),a("code",[e._v("exec")]),e._v("方法，就可以将这三组匹配结果提取出来。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\n\nconst matchObj = RE_DATE.exec('1999-12-31');\nconst year = matchObj[1]; // 1999\nconst month = matchObj[2]; // 12\nconst day = matchObj[3]; // 31\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如"),a("code",[e._v("matchObj[1]")]),e._v("）引用，要是组的顺序变了，引用的时候就必须修改序号。")]),e._v(" "),a("p",[e._v("ES2018 引入了"),a("a",{attrs:{href:"https://github.com/tc39/proposal-regexp-named-groups",target:"_blank",rel:"noopener noreferrer"}},[e._v("具名组匹配"),a("OutboundLink")],1),e._v("（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const RE_DATE = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n\nconst matchObj = RE_DATE.exec(\'1999-12-31\');\nconst year = matchObj.groups.year; // "1999"\nconst month = matchObj.groups.month; // "12"\nconst day = matchObj.groups.day; // "31"\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（"),a("code",[e._v("?<year>")]),e._v("），然后就可以在"),a("code",[e._v("exec")]),e._v("方法返回结果的"),a("code",[e._v("groups")]),e._v("属性上引用该组名。同时，数字序号（"),a("code",[e._v("matchObj[1]")]),e._v("）依然有效。")]),e._v(" "),a("p",[e._v("具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。")]),e._v(" "),a("p",[e._v("如果具名组没有匹配，那么对应的"),a("code",[e._v("groups")]),e._v("对象属性会是"),a("code",[e._v("undefined")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const RE_OPT_A = /^(?<as>a+)?$/;\nconst matchObj = RE_OPT_A.exec('');\n\nmatchObj.groups.as // undefined\n'as' in matchObj.groups // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("上面代码中，具名组"),a("code",[e._v("as")]),e._v("没有找到匹配，那么"),a("code",[e._v("matchObj.groups.as")]),e._v("属性值就是"),a("code",[e._v("undefined")]),e._v("，并且"),a("code",[e._v("as")]),e._v("这个键名在"),a("code",[e._v("groups")]),e._v("是始终存在的。")]),e._v(" "),a("h3",{attrs:{id:"解构赋值和替换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解构赋值和替换"}},[e._v("#")]),e._v(" 解构赋值和替换")]),e._v(" "),a("p",[e._v("有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');\none  // foo\ntwo  // bar\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("字符串替换时，使用"),a("code",[e._v("$<组名>")]),e._v("引用具名组。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\n\n'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')\n// '02/01/2015'\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("上面代码中，"),a("code",[e._v("replace")]),e._v("方法的第二个参数是一个字符串，而不是正则表达式。")]),e._v(" "),a("p",[a("code",[e._v("replace")]),e._v("方法的第二个参数也可以是函数，该函数的参数序列如下。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("'2015-01-02'.replace(re, (\n   matched, // 整个匹配结果 2015-01-02\n   capture1, // 第一个组匹配 2015\n   capture2, // 第二个组匹配 01\n   capture3, // 第三个组匹配 02\n   position, // 匹配开始的位置 0\n   S, // 原字符串 2015-01-02\n   groups // 具名组构成的一个对象 {year, month, day}\n ) => {\n let {day, month, year} = groups;\n return `${day}/${month}/${year}`;\n});\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br")])]),a("p",[e._v("具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。")]),e._v(" "),a("h3",{attrs:{id:"引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[e._v("#")]),e._v(" 引用")]),e._v(" "),a("p",[e._v("如果要在正则表达式内部引用某个“具名组匹配”，可以使用"),a("code",[e._v("\\k<组名>")]),e._v("的写法。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("数字引用（"),a("code",[e._v("\\1")]),e._v("）依然有效。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const RE_TWICE = /^(?<word>[a-z]+)!\\1$/;\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("这两种引用语法还可以同时使用。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>!\\1$/;\nRE_TWICE.test('abc!abc!abc') // true\nRE_TWICE.test('abc!abc!ab') // false\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("h2",{attrs:{id:"d-修饰符-正则匹配索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#d-修饰符-正则匹配索引"}},[e._v("#")]),e._v(" d 修饰符：正则匹配索引")]),e._v(" "),a("p",[e._v("组匹配的结果，在原始字符串里面的开始位置和结束位置，目前获取并不是很方便。正则实例的"),a("code",[e._v("exec()")]),e._v("方法有一个"),a("code",[e._v("index")]),e._v("属性，可以获取整个匹配结果的开始位置。但是，组匹配的每个组的开始位置，很难拿到。")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tc39/proposal-regexp-match-Indices",target:"_blank",rel:"noopener noreferrer"}},[e._v("ES2022"),a("OutboundLink")],1),e._v(" 新增了"),a("code",[e._v("d")]),e._v("修饰符，这个修饰符可以让"),a("code",[e._v("exec()")]),e._v("、"),a("code",[e._v("match()")]),e._v("的返回结果添加"),a("code",[e._v("indices")]),e._v("属性，在该属性上面可以拿到匹配的开始位置和结束位置。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const text = 'zabbcdef';\nconst re = /ab/d;\nconst result = re.exec(text);\n\nresult.index // 1\nresult.indices // [ [1, 3] ]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("上面示例中，"),a("code",[e._v("exec()")]),e._v("方法的返回结果"),a("code",[e._v("result")]),e._v("，它的"),a("code",[e._v("index")]),e._v("属性是整个匹配结果（"),a("code",[e._v("ab")]),e._v("）的开始位置。由于正则表达式"),a("code",[e._v("re")]),e._v("有"),a("code",[e._v("d")]),e._v("修饰符，"),a("code",[e._v("result")]),e._v("现在就会多出一个"),a("code",[e._v("indices")]),e._v("属性。该属性是一个数组，它的每个成员还是一个数组，包含了匹配结果在原始字符串的开始位置和结束位置。由于上例的正则表达式"),a("code",[e._v("re")]),e._v("没有包含组匹配，所以"),a("code",[e._v("indices")]),e._v("数组只有一个成员，表示整个匹配的开始位置是"),a("code",[e._v("1")]),e._v("，结束位置是"),a("code",[e._v("3")]),e._v("。")]),e._v(" "),a("p",[e._v("注意，开始位置包含在匹配结果之中，相当于匹配结果的第一个字符的位置。但是，结束位置不包含在匹配结果之中，是匹配结果的下一个字符。比如，上例匹配结果的最后一个字符"),a("code",[e._v("b")]),e._v("的位置，是原始字符串的 2 号位，那么结束位置"),a("code",[e._v("3")]),e._v("就是下一个字符的位置。")]),e._v(" "),a("p",[e._v("如果正则表达式包含组匹配，那么"),a("code",[e._v("indices")]),e._v("属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const text = 'zabbcdef';\nconst re = /ab+(cd)/d;\nconst result = re.exec(text);\n\nresult.indices // [ [ 1, 6 ], [ 4, 6 ] ]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("上面例子中，正则表达式"),a("code",[e._v("re")]),e._v("包含一个组匹配"),a("code",[e._v("(cd)")]),e._v("，那么"),a("code",[e._v("indices")]),e._v("属性数组就有两个成员，第一个成员是整个匹配结果（"),a("code",[e._v("abbcd")]),e._v("）的开始位置和结束位置，第二个成员是组匹配（"),a("code",[e._v("cd")]),e._v("）的开始位置和结束位置。")]),e._v(" "),a("p",[e._v("下面是多个组匹配的例子。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const text = 'zabbcdef';\nconst re = /ab+(cd(ef))/d;\nconst result = re.exec(text);\n\nresult.indices // [ [1, 8], [4, 8], [6, 8] ]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("上面例子中，正则表达式"),a("code",[e._v("re")]),e._v("包含两个组匹配，所以"),a("code",[e._v("indices")]),e._v("属性数组就有三个成员。")]),e._v(" "),a("p",[e._v("如果正则表达式包含具名组匹配，"),a("code",[e._v("indices")]),e._v("属性数组还会有一个"),a("code",[e._v("groups")]),e._v("属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const text = 'zabbcdef';\nconst re = /ab+(?<Z>cd)/d;\nconst result = re.exec(text);\n\nresult.indices.groups // { Z: [ 4, 6 ] }\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("上面例子中，"),a("code",[e._v("exec()")]),e._v("方法返回结果的"),a("code",[e._v("indices.groups")]),e._v("属性是一个对象，提供具名组匹配"),a("code",[e._v("Z")]),e._v("的开始位置和结束位置。")]),e._v(" "),a("p",[e._v("如果获取组匹配不成功，"),a("code",[e._v("indices")]),e._v("属性数组的对应成员则为"),a("code",[e._v("undefined")]),e._v("，"),a("code",[e._v("indices.groups")]),e._v("属性对象的对应成员也是"),a("code",[e._v("undefined")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const text = 'zabbcdef';\nconst re = /ab+(?<Z>ce)?/d;\nconst result = re.exec(text);\n\nresult.indices[1] // undefined\nresult.indices.groups['Z'] // undefined\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("上面例子中，由于组匹配"),a("code",[e._v("ce")]),e._v("不成功，所以"),a("code",[e._v("indices")]),e._v("属性数组和"),a("code",[e._v("indices.groups")]),e._v("属性对象对应的组匹配成员"),a("code",[e._v("Z")]),e._v("都是"),a("code",[e._v("undefined")]),e._v("。")]),e._v(" "),a("h2",{attrs:{id:"string-prototype-matchall"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-prototype-matchall"}},[e._v("#")]),e._v(" String.prototype.matchAll()")]),e._v(" "),a("p",[e._v("如果一个正则表达式在字符串里面有多个匹配，现在一般使用"),a("code",[e._v("g")]),e._v("修饰符或"),a("code",[e._v("y")]),e._v("修饰符，在循环里面逐一取出。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('var regex = /t(e)(st(\\d?))/g;\nvar string = \'test1test2test3\';\n\nvar matches = [];\nvar match;\nwhile (match = regex.exec(string)) {\n  matches.push(match);\n}\n\nmatches\n// [\n//   ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"],\n//   ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"],\n//   ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]\n// ]\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br")])]),a("p",[e._v("上面代码中，"),a("code",[e._v("while")]),e._v("循环取出每一轮的正则匹配，一共三轮。")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tc39/proposal-string-matchall",target:"_blank",rel:"noopener noreferrer"}},[e._v("ES2020"),a("OutboundLink")],1),e._v(" 增加了"),a("code",[e._v("String.prototype.matchAll()")]),e._v("方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const string = \'test1test2test3\';\nconst regex = /t(e)(st(\\d?))/g;\n\nfor (const match of string.matchAll(regex)) {\n  console.log(match);\n}\n// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]\n// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]\n// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[e._v("上面代码中，由于"),a("code",[e._v("string.matchAll(regex)")]),e._v("返回的是遍历器，所以可以用"),a("code",[e._v("for...of")]),e._v("循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。")]),e._v(" "),a("p",[e._v("遍历器转为数组是非常简单的，使用"),a("code",[e._v("...")]),e._v("运算符和"),a("code",[e._v("Array.from()")]),e._v("方法就可以了。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 转为数组的方法一\n[...string.matchAll(regex)]\n\n// 转为数组的方法二\nArray.from(string.matchAll(regex))\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("h3",{attrs:{id:"留言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#留言"}},[e._v("#")]),e._v(" 留言")])])}),[],!1,null,null,null);s.default=t.exports}}]);
[TOC]

# JavaScript - Algorithms（JavaScript 算法与数据结构）

## 数据结构

> 数据结构是在计算机中组织和存储数据的一种特殊方式，使得数据可以高效地被访问和修改。更确切地说，数据结构是数据值的集合，表示数据之间的关系，也包括了作用在数据上的函数或操作。

- $\star$ 链表
- $\star$ 双向链表
- $\star$ 队列
- $\star$ 栈
- $\star$ 哈希表
- $\star$ 堆 - 最大堆 & 最小堆
- $\star$ 优先队列
- $\star\star$ 字典树
- $\star\star$ 树
  - $\star\star$ 二叉查找树
  - $\star\star$ - AVL 树
  - $\star\star$ 红黑树
  - $\star\star$ 线段树 - 使用 最小/最大/总和 范围查询示例
  - $\star\star$ 树状数组 (二叉索引树)
- $\star\star$ 图 (有向图与无向图)
- $\star\star$ 并查集
- $\star\star$ 布隆过滤器

## 算法

> 算法是如何解决一类问题的明确规范。算法是一组精确定义操作序列的规则。

### 算法主题

#### 数学

- $\star$ - Bit 操控 - set/get/update/clear 位、乘以/除以二进制位 、变负等
- $\star$ 阶乘
- $\star$ 斐波那契数 - 经典 和 闭式 版本
- $\star$ 素数检测 (排除法)
- $\star$ 欧几里得算法 - 计算最大公约数 (GCD)
- $\star$ 最小公倍数 (LCM)
- $\star$ 素数筛 - 查找任意给定范围内的所有素数
- $\star$ 判断 2 次方数 - 检查数字是否为 2 的幂 (原生和按位算法)
- $\star$ 杨辉三角形
- $\star$ 复数 - 复数及其基本运算
- $\star$ 弧度和角 - 弧度与角的相互转换
- $\star$ 快速算次方
- $\star\star$ 整数拆分
- $\star\star$ 割圆术 - 基于 N-gons 的近似 π 计算
- $\star\star$ 离散傅里叶变换 - 把时间信号解析成构成它的频率

#### 集合

- $\star$ 笛卡尔积 - 多集合结果
- $\star\star$ 洗牌算法 - 随机置换有限序列
- $\star\star$ 幂集 - 该集合的所有子集
- $\star\star$ 排列 (有/无重复)
- $\star\star$ 组合 (有/无重复)
- $\star\star$ 最长公共子序列 (LCS)
- $\star\star$ 最长递增子序列
- $\star\star$ 最短公共父序列 (SCS)
- $\star\star$ 背包问题 - 0/1 和 无边界 问题
- $\star\star$ 最大子数列问题 - - BF 算法 和 动态规划
- $\star\star$ 组合求和 - 查找形成特定总和的所有组合

#### 字符串

- $\star$ 汉明距离 - 符号不同的位置数
- $\star\star$ 莱温斯坦距离 - 两个序列之间的最小编辑距离
- $\star\star$ Knuth–Morris–Pratt 算法 KMP 算法 - 子串搜索 (模式匹配)
- $\star\star$ 字符串快速查找 - 子串搜索 (模式匹配)
- $\star\star$ Rabin Karp 算法 - 子串搜索
- $\star\star$ 最长公共子串
- $\star\star$ 正则表达式匹配

#### 搜索

- $\star$ 线性搜索
- $\star$ 跳转搜索/块搜索 - 搜索有序数组
- $\star$ 二分查找 - 搜索有序数组
- $\star$ 插值搜索 - 搜索均匀分布的有序数组

#### 排序

- $\star$ 冒泡排序
- $\star$ 选择排序
- $\star$ 插入排序
- $\star$ 堆排序
- $\star$ 归并排序
- $\star$ 快速排序 - in-place (原地) 和 non-in-place 版本
- $\star$ 希尔排序
- $\star$ 计数排序
- $\star$ 基数排序

#### 链表

- $\star$ 正向遍历
- $\star$ 反向遍历

#### 树

- $\star$ 深度优先搜索 (DFS)
- $\star$ 广度优先搜索 (- BFS)

#### 图

- $\star$ 深度优先搜索 (DFS)
- $\star$ 广度优先搜索 (- BFS)
- $\star$ 克鲁斯克尔演算法 - 寻找加权无向图的最小生成树 (MST)
- $\star\star$ 戴克斯特拉算法 - 找到图中所有顶点的最短路径
- $\star\star$ 贝尔曼-福特算法 - 找到图中所有顶点的最短路径
- $\star\star$ 弗洛伊德算法 - 找到所有顶点对 之间的最短路径
- $\star\star$ 判圈算法 - 对于有向图和无向图 (基于 DFS 和不相交集的版本)
- $\star\star$ 普林演算法 - 寻找加权无向图的最小生成树 (MST)
- $\star\star$ 拓扑排序 - DFS 方法
- $\star\star$ 关节点 - Tarjan 算法 (基于 DFS)
- $\star\star$ 桥 - 基于 DFS 的算法
- $\star\star$ 欧拉回径与一笔画问题 - Fleury 的算法 - 一次访问每个边
- $\star\star$ 哈密顿图 - 恰好访问每个顶点一次
- $\star\star$ 强连通分量 - Kosaraju 算法
- $\star\star$ 旅行推销员问题 - 尽可能以最短的路线访问每个城市并返回原始城市

#### 加密

- $\star$ 多项式 hash - 基于多项式的 rolling hash 函数

#### 未分类

- $\star$ 汉诺塔
- $\star$ 旋转矩阵 - 原地算法
- $\star$ 跳跃游戏 - 回溯,、动态编程 (自上而下+自下而上) 和贪婪的例子
- $\star$ 独特(唯一) 路径 - 回溯、动态编程和基于 Pascal 三角形的例子
- $\star$ 雨水收集 - 诱捕雨水问题 (动态编程和暴力版本)
- $\star$ 递归楼梯 - 计算有共有多少种方法可以到达顶层 (4 种解题方案)
- $\star\star$ 八皇后问题
- $\star\star$ 骑士巡逻

### 算法范式

> 算法范式是一种通用方法，基于一类算法的设计。这是比算法更高的抽象，就像算法是比计算机程序更高的抽象。

#### - $\star$F 算法 - 查找/搜索 所有可能性并选择最佳解决方案

- $\star$ 线性搜索
- $\star$ 雨水收集 - 诱导雨水问题
- $\star$ 递归楼梯 - 计算有共有多少种方法可以到达顶层 (4 种解题方案)
- $\star\star$ 最大子数列
- $\star\star$ 旅行推销员问题 - 尽可能以最短的路线访问每个城市并返回原始城市
- $\star\star$ 离散傅里叶变换 - 把时间信号解析成构成它的频率

#### 贪心法 - 在当前选择最佳选项，不考虑以后情况

- $\star$ 跳跃游戏
- $\star\star$ 背包问题
- $\star\star$ 戴克斯特拉算法 - 找到所有图顶点的最短路径
- $\star\star$ 普里姆算法 - 寻找加权无向图的最小生成树 (MST)
- $\star\star$ 克鲁斯卡尔算法 - 寻找加权无向图的最小生成树 (MST)

#### 分治法 - 将问题分成较小的部分，然后解决这些部分

- $\star$ 二分查找
- $\star$ 汉诺塔
- $\star$ 杨辉三角形
- $\star$ 欧几里得算法 - 计算最大公约数 (GCD)
- $\star$ 归并排序
- $\star$ 快速排序
- $\star$ 树深度优先搜索 (DFS)
- $\star$ 图深度优先搜索 (DFS)
- $\star$ 跳跃游戏
- $\star$ 快速算次方
- $\star\star$ 排列 (有/无重复)
- $\star\star$ 组合 (有/无重复)

#### 动态编程 - 使用以前找到的子解决方案构建解决方案

- $\star$ 斐波那契数
- $\star$ 跳跃游戏
- $\star$ 独特路径
- $\star$ 雨水收集 - 疏导雨水问题
- $\star$ 递归楼梯 - 计算有共有多少种方法可以到达顶层 (4 种解题方案)
- $\star\star$ 莱温斯坦距离 - 两个序列之间的最小编辑距离
- $\star\star$ 最长公共子序列 (LCS)
- $\star\star$ 最长公共子串
- $\star\star$ 最长递增子序列
- $\star\star$ 最短公共子序列
- $\star\star$ 0-1 背包问题
- $\star\star$ 整数拆分
- $\star\star$ 最大子数列
- $\star\star$ 贝尔曼-福特算法 - 找到所有图顶点的最短路径
- $\star\star$ 弗洛伊德算法 - 找到所有顶点对之间的最短路径
- $\star\star$ 正则表达式匹配

#### 回溯法 - 类似于 - BF 算法 试图产生所有可能的解决方案，但每次生成解决方案测试如果它满足所有条件，那么只有继续生成后续解决方案。否则回溯并继续寻找不同路径的解决方案。

- $\star$ 跳跃游戏
- $\star$ 独特路径
- $\star\star$ 幂集 - 该集合的所有子集
- $\star\star$ 哈密顿图 - 恰好访问每个顶点一次
- $\star\star$ 八皇后问题
- $\star\star$ 骑士巡逻
- $\star\star$ 组合求和 - 从规定的总和中找出所有的组合

#### - Branch & - Bound - 记住在回溯搜索的每个阶段找到的成本最低的解决方案，并使用到目前为止找到的成本最小值作为下限。以便丢弃成本大于最小值的解决方案。通常，使用 - BFS 遍历以及状态空间树的 DFS 遍历。

# this 指向

- [this 是什么](#this-是什么)
- [this 的绑定机制](#this-的绑定机制)
- [箭头函数 this 指向](#箭头函数-this-指向)

## this 是什么

> this 既不指向函数自身也不指向函数的词法作用域，this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用

## this 的绑定机制

- 默认绑定

> 默认绑定一般发生在回调函数,函数直接调用;

```js
var name = "this";
// window.name="this";
function fn() {
  return this.name;
}
fn(); //"this" // window.fn()=>window.name
```

- 隐式绑定

> 通俗来说谁最终调用函数，this 指向谁

- 隐式丢失

> 一个最常见的 this 绑定问题是被隐式绑定的函数会丢失绑定对象，也就是你说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式

- 显示绑定 call，apply，bind

> 相对隐式绑定，this 值在调用过程中会动态变化，可是我们就想绑定指定的对象，这时就用到了显示绑定。

- new 绑定

## 箭头函数 this 指向

> 首先需要明确，箭头函数不适用以上 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this
>
> 箭头函数 this 的定义：箭头函数中的 this 是在定义函数的时候绑定，而不是在执行函数的时候绑定 。

this 指针的介绍
什么是 this 指针。
this 指针是指向某个对象空间的指针，一般情况下是指向（和强类型语言一样）定义当前作用域所在的对象示例代码。如示例代码所示，logName 函数中的 this 指针指向了 objA 对象（logName 的作用域是在 objA 对象中定义的）。所以输出了 aaa。
接着看上面的示例代码，我们在后面定义了一个没有 logName 函数的对象 objB,但没有定义 logName 函数。那需要输出 objB 中的 name 要这么办呢？我们能不能向 objA 对象借用一下 logName 函数？让 objA 里面的 this 指针指向 objB 对象呢？
JS 中 this 指针的特点
不同于强语言的是，JS 中的 this 指针是可以通过修改，动态变化的。我们可以通过修改 this 指针来实现上面的需求。如示例代码。
比较两个例子，可以发现，第二个代码多加了 bind(objB)。是这里改变了 this 指针的指向吗？是的。其实在 JS 中。有三个函数可以改变 this 指针的指向。分别是 bind，call，和 apply 函数。
bind，call，apply 的介绍和比较
先来看看这三个函数的使用示例示例代码。
首先，三个里面，最突出的函数就是 bind。为什么唯独 bind 函数不是直接使用。还需要在外面添加一个 setTimeout 呢？如果不加 setTimeout 会怎么样呢？示例代码。在不加 setTimeout 的时候没有输出任何东西。而加了 setTimeout 才会输出。其实那是因为使用 bind 的时候，是仅仅修改 this 指针，并不会执行函数。在 setTimeout 中，计时后，才由 setTimeout 去调用执行这个函数。
接着，call 和 apply 直接执行了函数。他们的区别是什么呢？他们唯一的区别是传参方式的不同，call 函数以枚举（即直接列出来）的方式传参。而 apply 是以数组的方式传参的。我们试一下调转过来传参示例代码
彩蛋，除了使用 bind 来修改 this 指针以外。我们还可以使用它来返回一个函数，往后再去执行。示例代码。其实这个实例中并没什么卵用，只是这个实例说明两个问题。
当 bind 函数的第一个参数传 null 时，表示不改变函数中 this 的指向。
当函数前面的参数已经被赋值时，再使用 bind 时，是从剩余没有赋值的函数参数开始赋值的。
this 指针的应用
将 this 的指针指向正确的值。这个内容后面再讲。
利用 this 指针借用某对象的函数，前面的几个例子就是利用了 this 指针借用函数。在介绍更多例子之前，我们先插入一个伪数组的概念
伪数组是指哪些只有 length 和中括索引功能，没有数组相应功能函数的数据结构。例如示例代码。如这个例子中 pList1 就没有 slice 的函数。
在前端中最经常接触到的伪数组有函数中的隐藏变量 arguments 和用 getElementsByTagName 获得到的元素集合。
这时我们就可以利用到 this 指针去借用数组中的函数，实现我们想要的目的。示例代码
另外怎么把伪数组转化为真数组呢？其实只要在上一个例子上再修改一下就可以了。示例代码
在此基础上，我们还可以利用 this 指针实现一部分类功能。示例代码
this 指针与作用域的关系（主要是 window）
其实如果没有该死的 window 对象的话，原本 this 指针和作用域是没有太大关系的
先看代码，示例代码。！！！？居然输出的是 HanMeiMei 而不是 LiLei？为什么会输出 HanMeiMei?这是不是意味着 this 指针发生变化了？我们 log 一下 this 指针的值.
示例代码。果然，this 指针真的是指向了 window？？WTF？我们明明没有修改过 this 指针的值啊？为什么 this 的指向改变了？
在这里就要补充一下的 this 指针的定义了。上面讲到（一般情况下是指向定义当前作用域时所在的对象，即在那个对象内定义就是指向谁。）。但实际上，this 是指向通过点操作符（如 objA.funA()）调用本函数的那个对象。即谁调用我，我就指向谁。示例代码如在这里，objB 并没有定义 logName 函数。只是定义了一个变量并赋值为函数的引用。这时使用 objB.logName 实际上调用的是 objA 对象里面的函数。而 log 出来的对象就是 objB。
再回到 setTimeout 函数。我们前面 log 过 this，发现 this 是指向 window 的。这证明在 setTimeout 中的是 window 对象去调用 logName 的。即相当于 window.logName();发现问题了吗？HanMeiMei 既是作用域中的变量，也是 window 对象中的变量。
实际上，所有在全局作用域(注意仅仅是全局作用域)中定义的变量都是 window 对象下的变量。都可以通过 window 对象进行访问。所以一旦没有通过对象去调用某函数，而是直接运行的话（如不是 objA.fun（）而是直接 fun()），等价于在 window 下调用（fun()等价于 window.fun()）。this 指针的值都指向 window。
再由于所有在全局作用域(注意仅仅是全局作用域)中定义的变量都是 window 对象下的变量所以 logName 中的值指指向了 window.name。也就是作用域中的 name 值。作用域就是通过 window 与 this 指针挂上了关系。
this 指针和闭包的比较
这是一个性能优化的探讨问题。
有时候我们会遇到这样的情况。使用闭包和 this 指针都可以实现同样的功能。例如示例代码。使用这两种方式均可以成功 log 出 name 的值。那这时候我们使用哪个好呢？
由于 log 函数会输出到控制台，执行速度慢，我们通过修改 name 的值来模拟内部操作示例代码可以看到。直接使用闭包的性能更佳。性能是使用 bind 的 5 倍以上。由于时间原因。原理我就不再这里介绍了。有兴趣的同学可以通过这个链接看看.为什么闭包比 this 更快
至此，本教程中，最困难的两个点（this 指针与 JS 线程）中的其中一个已经介绍完了。接下来休息一下，穿插几个比较简单的概念。
